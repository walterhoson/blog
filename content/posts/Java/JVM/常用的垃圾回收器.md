---
title: 常用的垃圾收集器
description: 分析 Java 中常用的垃圾收集器的工作原理，以及优化思路
toc: true
authors: 
    - WayneShen
tags: 
    - Java
    - JVM
categories: 
    - Java
series: []
date: '2020-04-21T20:41:+08:00'
lastmod: '2020-04-21T20:42:00+08:00'
draft: false
---

</br>

分析 Java 中常用的垃圾收集器的工作原理，以及优化思路

<!--more-->

常用的垃圾收集器有：

+ 新生代收集器：Serial、ParNew、Parallel Scavenge；
+ 老年代收集器：Serial Old、Parallel Old、CMS；
+ 整堆收集器：G1；

![常用的垃圾收集器](../../../assets/常用的垃圾回收器/image-20210710162102559.png)

JDK8 默认使用：Parallel Scavenge + Parallel Old

## Serial

Serial 是应用于新生代的垃圾收集器，使用单线程的复制收集算法；

单线程进行垃圾回收，垃圾回收时会停止系统中的其他工作线程（STW），系统会直接暂停，让收集器进行垃圾回收，已经几乎不再使用。

一般在单核的机器上使用，是 Java1.5 非服务端 JVM 的默认收集器，参数 `-XX:UseSerialGC` 设置使用。

优势：

+ 对于单 CPU 环境来说，Serial 收集器没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集。
+ Serial 收集器对于在 Client 模式下的虚拟机是一个很好的选择。

## Serial Old

Serial Old 是应用于老年代的垃圾收集器，使用单线程的标记-整理算法。

收集器的意义在于给 Client 模式下的虚拟机使用。

如果在 Server 模式下，那么它主要有两大用途：

+ 在 Java1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，
+ 作为 CMS 收集器的后预案，在并发收集发生 `Concurrent Mode Failure` 时使用。

## ParNew

ParNew 是 Serial 收集器的多线程版本，也是目前线上常用的**新生代垃圾收集器**。

### 原理

使用**多线程**进行垃圾回收，大幅度提升回收的性能，缩短回收的时间。通过参数 `-XX:+UseParNewGC` 设置。

垃圾回收的并发线程数默认保持与 CPU 核心数一致，无需手动调节。也可以通过  `-XX:ParallelGCThreads` 参数手动设置线程数量。

参数控制：

+ `-XX:+UseConcMarkSweepGC`：指定使用 CMS 后，会默认使用 ParNew 作为新生代收集器；
+ `-XX:+UseParNewGC`：强制指定使用 ParNew；
+ `-XX:ParallelGCThreads`：指定垃圾收集的线程数量，ParNew 默认开启的收集线程与 CPU 的数量相同；

ParNew 收集器是许多运行在 server 模式下的虚拟机中首选的新生代收集器，一个重要的原因是：

只有 ParNew 和 Serial 收集器能和 CMS 收集器共同工作。无法与 JDK1.4 中存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代时，新生代只能选择 ParNew 和 Serial。

ParNew 收集器在单 CPU 环境中不比 Serial 效果好，甚至可能更差，两个 CPU 也不一定跑的过，但随着 CPU 数量的增加，性能会逐步增加。

默认开启的收集线程数与 CPU 数相同。在 CPU 数量很多的情况下，可以使用 `-XX:ParallelGCThreads` 参数来限制线程数。

### 优化思路

+ 合理设置新生代内存大小、Eden 和 Survivor 的比例
+ 避免 Minor GC 后对象在 Survivor 放不下而进入老年代，或动态年龄判定之后进入老年代
+ 给新生代里的 Survivor 充足的空间

## Parallel Scavenge

Parallel Scavenge 收集器是一个**多线程**的**新生代**收集器，使用**复制算法**。目标是达到一个可控制的吞吐量。

参数设置：

+ 通过 `-XX:MaxGCPauseMillus` 参数，**控制垃圾停顿时间**。
+ 通过 `-XX:GCTimeRatio` 参数，**控制吞吐量**。
+ 通过 `-XX:UseAdaptiveSizePolicy` 参数，JVM 会根据当前系统的运行情况收集性能监控信息。

动态调整这些参数以提供最合适的停顿时间或者最大吞吐量（GC 自适应的调节策略）。

自适应调节策略也是 Parallel Scavenge 收集器和 ParNew 收集器一个重要的区别。

## Parallel Old

属于 Parallel Scavenge 收集器的老年代版，使用**多线程**与**标记–整理算法**。是 JDK8 默认的垃圾收集器。

到 Java1.6 才开始提供。直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了名副其实的应用组合，在**注重吞吐量**以及 **CPU 资源敏感**的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

## CMS 垃圾收集器

CMS 是用在老年代的垃圾收集器，多线程并发的机制，性能更好，生产经常使用。

### 原理

采用 **标记-清理算法**，先追踪 GC Roots，看各个对象是否被 GC Roots 引用，若是表示存活对象，否则就是垃圾对象。

若 STW，然后慢慢的去执行“标记-清理”算法，会导致系统卡死时间过长，很多响应无法处理。所以 CMS 垃圾收集器采取的是**垃圾回收线程和系统工作线程尽量同时执行的模式**来处理。

**执行过程**

CMS 执行一次垃圾回收的过程共分为 4 个阶段：

**1. 初始标记**

标记出所有 GC Roots 直接引用的对象，此时需要 STW，暂停一切工作线程，但其实影响不大，因为标记速度很快，仅仅标记 GC Roots 直接引用的那些对象。

**2. 并发标记**

该阶段会让系统线程继续运行，可随意创建新对象。在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在此过程中，垃圾回收线程会尽可能的对已有的对象进行 GC Roots 追踪。此时不会 STW。

**3. 重新标记**

remark，第二阶段结束后，肯定**会有很多存活对象和垃圾对象是第二阶段没标记出来**的，此时就要 STW，然后**重新标记在第二阶段里新创建的一些对象**，还有一些对象可能失去引用变成垃圾的情况。该阶段**速度很快**，因为其实就是**对在第二阶段中被系统程序运行变动过的少数对象进行标记**。

**4. 并发清理**

让系统程序随意运行，然后垃圾收集器来清理掉之前标记为垃圾的对象，该阶段比较耗时，因为需要进行对象的清理，但是与系统程序并发运行，所以其实不影响系统程序的执行。

在 remark 之前，添加一次可中断的并发预清理（其实就是继续执行并发标记），为了防止并发预清理阶段等太久都不发生 YGC，提供 `CMSMaxAbortablePrecleanTime` 参数来设置等待多久没有等到 YGC 就强制 remark，默认 5s。但最终一劳永逸的方法是，添加参数 `CMSScavengeBeforeRemark`，让 remark 之前强制 YGC。

### 性能分析

最耗时的其实就是对老年代全部对象进行 GC Roots 追踪，标记出来到底哪些可以回收（第二阶段），然后就是对垃圾对象的清理（第四阶段）。但因为这两个阶段是并发执行的，所以最耗时的对性能影响不大。只有第一个阶段和第三个阶段是需要 STW 的，但是这两个阶段都是简单的标记而已，速度非常的快，所以基本上对系统运行响应的影响也不大。

### 存在问题

**消耗 CPU 资源**

CMS 虽然能并发处理，但在并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的 CPU 资源被垃圾回收线程占用了一部分。**CMS 默认启动的垃圾回收线程的数量是 (CPU 核数 + 3) / 4**。

**Concurrent Mode Failure 问题**

在并发清理阶段，CMS 只不过是回收之前标记好的垃圾对象。但这个阶段系统一直运行，此时可能让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是“浮动垃圾”。这些浮动垃圾，要到下次 FGC 才能回收了。所以还有需要预留一些空间。

CMS 垃圾回收的触发时机中，其中一个是当老年代内存占用达到一定比例了就自动执行 GC。参数 `-XX:CMSInitiatingOccupancyFaction` 可以设置这个比例，JDK1.6 里面默认的值是 92%。当老年代占据 92%空间时，就自动进行 CMS 垃圾回收，预留 8% 的空间给并发回收期间，系统程序把一些新对象放入老年代中。

若此时需要进入老年代的对象大于老年代剩余内存，就发生了 Concurrent Mode Failure，并发回收失败。此时会自动使用 “Serial Old” 垃圾收集器来替代，强行 STW，重新进行长时间的 GC Roots 追踪，标记出全部垃圾对象，不允许新的对象产生。一次性回收完之后，之后再恢复系统线程。所以这个比例需要合理优化。

参数 `-XX:+CMSScavengeBeforeRemark` 表示，会在 CMS 的**重新标记（remark）**阶段之前，先尽量执行一次 YGC。如此一来重新标记阶段就可以少扫描一些对象，提升重新标记阶段的性能。？？？

**内存碎片问题**

CMS 采用“标记-清理”算法，若仅仅使用该算法，则容易导致内存碎片过多，大对象无法放入，导致频繁 FGC。

所以 CMS 有一个参数 `-XX:+UseCMSCompactAtFullCollection`，默认打开，意思是 FGC 后再次进行 STW，停止工作线程，进行碎片整理，把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。

还有个参数是 `-XX:CMSFullGCsBeforeCompaction`，表示执行多少次 FGC 之后再执行一次内存碎片整理的工作，默认是 0，也就说，默认每次 FGC 后都会进行一次内存整理。

### FGC 比 YGC 慢很多

一般是慢 10 倍以上。新生代直接从 GC Roots 出发就追踪存活对象，新生代存活对象很少，速度是极快的。然后直接把存活对象放入 Survivor 中，就一次性直接回收 Eden 和之前使用的 Survivor 了。

CMS 的 FGC 的几个要点是：

+ 在并发标记阶段，需要去追踪所有存活对象，老年代存活对象很多，这个过程就会很慢；

+ 其次并发清理阶段，不是一次性回收一大片内存，而是找到零散在各个地方的垃圾对象，速度也很慢；

+ 最后还要执行一次内存碎片整理，把大量的存活对象挪在一起，空出连续内存空间，这个过程还要 STW，就更慢了。

+ 如果并发清理期间，剩余内存空间不足以存放要进入老年代的对象，引发了“Concurrent Mode Failure”问题，就更麻烦，需要立马用“Serial Old”垃圾收集器，STW 之后再重新来一遍回收的过程，就更耗时了。

## G1 垃圾收集器

G1（Garbage First）算法，通过参数 `-XX:+UseG1GC` 启用，主要是**为了解决 CMS 算法产生空间碎片和其他一些的问题缺陷**。

主要应用在 **多 CPU、大内存** 的服务中，**手动设置一个垃圾回收的预期停顿时间**，在满足高吞吐量的同时，尽可能的满足垃圾回收时的暂停时间，以防止出现大内存 GC 时长时间卡顿的问题，该设计主要针对如下应用场景：

+ 垃圾收集线程和应用线程并发执行，和 CMS 一样
+ 空闲内存压缩时避免冗长的暂停时间
+ 应用需要更多可预测的 GC 暂停时间
+ 不希望牺牲太多的吞吐性能
+ 不需要很大的 Java 堆

### 原理

统一收集新生代和老年代，采用了更加优秀的算法和设计机制，同时回收新生代和老年代，无需两个垃圾收集器配合。

特点是：**把堆内存拆分为多个大小相等的 Region**。新生代，老年代分别包含一些 Region，此时的新生代和老年代都只属于逻辑概念了，Region 随时会属于新生代也会属于老年代，所以没有所谓新生代/老年代给多少内存这一说了。

### 实现逻辑

G1 追踪每个 Region 里的回收价值，也就是说，它必须搞清楚每个 Region 里的对象有多少是垃圾；若要对这个 Region 进行垃圾回收，需要耗费多长时间；可以回收掉多少垃圾。

简单来说，G1 可以做到手动设定垃圾回收对系统的影响，通过把内存拆分为大量小 Region，以及追踪每个 Region 中可回收的对象大小和预估时间，最后在垃圾回收时，**尽量把垃圾回收对系统造成的影响控制在用户指定的时间范围内**，同时**在有限的时间内尽量回收尽可能多的垃圾对象**。

Region 的数量和大小，默认情况下自动计算和设置的，可以给整个堆内存设置一个大小，比如说用 `-Xms` 和 `-Xmx` 来设置堆内存的大小。JVM 启动时一旦发现使用的是 G1 垃圾收集器会自动**用堆大小除以 2048**。因为 **JVM 最多可以有 2048 个 Region，并且 Region 的大小必须是 2 的倍数**。

可以通过设置参数 `-XX:G1HeapRegionSize` 来**指定每个 Region 大小** ，一般保持默认，也就是**在堆初始化时计算 Region 实际大小**。

**起初默认新生代对堆内存的占比是 5%**，可以通过 `- XX:G1NewSizePercent` 来**设置新生代初始占比**，一般维持默认值即可。因为在系统运行中，JVM 其实会不停的给新生代增加更多的 Region，但**最多新生代的占比不会超过 60%**，可以通过 `- XX:G1MaxNewSizePercent` **设置最大占比**。而且一旦 Region 进行了垃圾回收，新生代的 Region 数量还会动态减少。

#### 新生代和老年代

G1 也分 Eden 和 Survivor，通过 `-XX:SurvivorRatio=8` 来设置划分出来的 Region 中哪些是 Eden 和 Survivor，随着对象不停的在新生代中分配，属于新生代的 Region 会不断增加，Eden 和 Survivor 对应的 Region 也会不断增加。直到新生代占据堆大小的最大比例（可配置，默认 60%），此时会触发 YGC，**G1 会用复制算法来进行YGC**，进入 STW 状态，然后把 Eden 对应的 Region 中的存活对象放入 S1 对应的 Region 中，接着回收掉 Eden 对应的 Region 中的垃圾对象。

与 CMS 不同的是，G1 是可以设定目标 GC 停顿时间的，也就是 **G1 执行 GC 时最多可以让系统停顿多长时间，可以通过 `-XX:MaxGCPauseMillis` 参数来设定，默认值是 200ms**。然后 G1 在有限的时间内回收尽可能多的垃圾对象。

#### 对象进入老年代时机

1. 对象在新生代躲过了多次的垃圾回收，达到了一定的年龄，`-XX:MaxTenuringThreshold` 参数可以设置这个年龄
2. **动态年龄判定规则**，一旦发现某次 YGC 过后，存活对象超过了 Survivor 的 50%，则将刚刚超过 50% 那个年龄以上的对象直接进入老年代。

#### 大对象的 Region

G1 提供了专门的 Region（Humongous）来存放大对象，而不是让大对象进入老年代的 Region 中。

在 G1 中，大对象的判定规则就是**一个大对象大小超过了一个 Region 的 50%**，若每个 Region 是 2MB，只要一个大对象超过了 1MB，就会被放入大对象专门的 Region 中。若一个大对象太大，可能会横跨多个 Region 来存放。

大对象不属于新生代和老年代，在新生代、老年代回收时，顺带大对象 Region 一起回收。

#### 混合垃圾回收

参数 `-XX:InitiatingHeapOccupancyPercent`，默认值是 45%。即：若老年代占据了堆内存的 45% 的 Region 时，此时就会尝试触发一个新生代 + 老年代一起回收的混合回收阶段。

**混合垃圾回收过程（Mixed GC）**

+ 首先会触发 **初始标记**，该过程需要 STW ，仅仅只是标记一下 GC Roots 直接能引用的对象，该过程速度很快。（对各个线程栈内存中的局部变量代表的 GC Roots，以及方法区中的类静态变量代表的 GC Roots 进行扫描，标记出来他们直接引用的对象）
+ **并发标记** 阶段，该阶段允许系统程序运行，同时进行 GC Roots 追踪存活的对象。比较耗时，但可以并发进行。同时 **JVM 会记录并发标记阶段对对象做出的一些修改**，比如哪些对象被建立/失去引用。
+ **最终标记** 阶段，需要 STW，但会根据并发标记阶段记录的那些对象修改，最终标记一下有哪些存活对象/垃圾对象。
+ **混合回收** 阶段，该阶段会计算老年代中每个 Region 中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。然后 STW，全力以赴进行垃圾回收，此时会选择部分 Region 进行回收，因为必须让垃圾回收停顿时间控制在我们制定范围内。

参数控制

+ G1 允许执行多次混合回收，参数 `-XX:G1MixedGCCountTarget`，默认值为 8，指的是在一次混合回收过程中，反复执行最后一个阶段混合回收的次数。这样可以尽可能让系统不停顿时间过长，可以在多次回收的间隙也运行一下。

+ G1 允许控制混合回收时间，参数 `-XX:G1HeapWastePercent`，默认值是 5%。在混合回收时，对 Region 回收都是基于复制算法进行的（不会出现内存碎片），都是把要回收的 Region 里的存活对象放入其他 Region，然后将这个 Region 中的垃圾对象全部清理掉，所以在回收过程中就会不断有空出来新的 Region，一旦空闲出来的 Region 数量达到堆内存的 5%，此时立刻停止混合回收，意味本次混合回收结束了。

+ 参数 `-XX:G1MixedGCLiveThresholdPercent`，默认值是 85%，即：确定要回收的 Region 时，必须是存活对象低于 85% 的 Region 才可以进行回收。因为若一个 Region 的存活对象多余 85%，拷贝到别的 Region 成本都很高。

#### 回收失败时的 FGC

进行 Mixed GC 时，年轻代和老年代都采用复制算法，将 Region 中存活的对象拷贝到别的 Region 中，若拷贝过程中发现没有空闲的 Region 可以承载存活的对象，就会触发一次失败，立刻 STW，采用单线程进行标记、清理和压缩整理，空闲出一批 Region，这个过程时极慢极慢的。

### 优化

#### YGC 优化

首先给整个 JVM 的堆区域足够的内存，然后合理设置 `-XX:MaxGCPauseMillis` 参数

+ 若设置小了，则会频繁进行短时间的 GC。
+ 若设置大了，则可能积累很多对象后再进行 GC，但是导致频率降低，但每次停顿时间较长。

所以尽量通过压测工具、GC 日志、内存分析工具结合判断，尽量让系统的 GC 频率别太高，同时每次 gc 停顿时间也别太长，达到一个理想的合理值。

#### Mixed GC 优化

主要思路是 **避免对象过快的进入老年代**，**尽量避免频繁触发 MixedGC**。所以核心就是调节 `-XX:MaxGCPauseMillis`。 

触发 MixedGC 就说明了老年代在堆内存中占比超过了 45%。而对象进入老年代，主要是 YGC 后存活对象太多无法放入 Survivor，或对象年龄太大，或动态年龄判定规则。

前两者尤其关键，最有可能导致很多对象快速进入老年代。比如 `-XX:MaxGCPauseMillis` 设置的值很大，导致系统运行很久，新生代占了堆的 60%，才触发 YGC，此时很多存活对象无法放入 Survivor 区，就会进入老年代。或 YGC 后，存活对象过多，导致进入 Survivor 区触发动态年龄判定规则，达到了 Survivor 的 50%，也快速导致了对象进入老年代。