---
title: 垃圾回收机制
description: 分析 Java 中对象的引用机制，分代算法的原理及优化思路
toc: true
authors: 
    - WayneShen
tags: 
    - Java
    - JVM
categories: 
    - Java
series: []
date: '2020-04-21T18:05:+08:00'
lastmod: '2020-04-21T23:40:00+08:00'
draft: false
---

</br>

分析 Java 中对象的引用机制，分代算法的原理及优化思路

<!--more-->

## 垃圾回收算法

常用的垃圾回收算法主要有

+ 标记清除 - 位置不连续、产生碎片（Mark-Sweep）
+ 拷贝算法 - 没有碎片、浪费空间（Copying）
+ 标记压缩 - 没有碎片、效率偏低（Mark-Compact）

### 定位垃圾

+ 引用计数
+ 根可达算法

## 分代算法

主要分为**新生代（New/Young）**和**老年代（Old）**

+ 新生代：存活对象少、使用 copy 算法，效率高。
+ 老年代：垃圾相对少、一般使用 Mark-compact 算法，G1 使用 copy 算法。

### 新生代复制算法

将新生代区域划分两块，对象生成后，先放入其中一块，到内存空间不足时，触发 Minor GC（YGC），并将仍存活的对象转移到另一块空白内存中。再一次性清空第一块内存区域，以此循环使用，以此解决内存碎片。

缺点是，因为只能使用一半，所以**内存使用效率太低**。

### 复制算法优化

划分两个区域，Eden 区和 Survivor 区。

由于基本新生代垃圾回收后，大部分对象都已被回收，小部分存活（可能是些长期存活对象或还没用完的对象），所以进行了优化；

**将新生代内存区域划分为三块**，1 个 Eden 区，2 个 Survivor 区，其中 Eden 区占 80% 内存空间，每块 Survivor 区各占 10% 内存空间。

平时可以使用的就是 Eden 区和其中一块 Survivor 区，相当于 90% 内存可以使用。

使用流程：

+ 起初对象都是分配在 Eden 区内，若 Eden 区快满了，此时触发 YGC；
+ 此时就会把 Eden 区中的存活对象都一次性转移到一块空的 Survivor 区；
+ 接着 Eden 区就会被清空，然后就会再次分配新对象到 Eden 区里；
+ 此时 Eden 区和一块 Survivor 区里有对象，Survivor 区存放的是上一次 YGC 后存活的对象。
+ 下次再次 Eden 区满，再次触发 YGC，就会把 Eden 区和放着上一次 YGC 后存活对象的 Survivor 区内的仍存活对象，转移到另外一块 Survivor 区；
+ 清空 Eden 区和之前使用的 Survivor 区域中的所有垃圾对象。始终保持一块 Survivor 区是空的；
+ 往复循环。

**优化后提高了内存的使用效率。**

对象每次在新生代里经过一次 YGC 被转移到一块 Survivor 区域中，年龄就加一，到达年龄上限后，仍存活的则进入老年代。

> 年龄上限，PS/G1 默认 15，CMS 为 6，通过 `-XX:MaxTenuringThreshold` 设置。

#### 动态年龄判断

动态年龄判断规则可以不等待 15 次 GC，让对象直接进入老年代。

假如当前放对象的 Survivor 区域里，一批对象的总大小（同龄对象）大于了这块 Survivor 区域的内存大小的 50%（`-XX:TargetSurvivorRatio`），那么此时大于等于这批对象年龄的对象，就可以直接进入老年代。

也就是说，**年龄 1 + 年龄 2 + 年龄 n 的多个年龄对象总和超过了 Survivor 区域的 50%，此时就会把年龄 n 以上的对象都放入老年代**。

此目的就是为了**希望长期存活的对象，尽早进入老年代**。

#### 进入老年代规则

JVM 参数 `-XX:PretenureSizeThreshold`，可以设置为字节数，比如`1048576`字节（1MB）。若**创建的对象大小超过该数值，则直接作为大对象放到老年代，不经过新生代**。为了避免大对象在新生代中来回复制，耗费时间。

若发生 YGC，Eden 区中存在较大对象，无法放入 Survivor 区，此时直接将对象移入老年代。

在 YGC 前，要对老年代空间做检查，即：**先判断老年代的可用内存是否小于新生代的全部对象大小**，小于则判断 JVM 参数 `-XX:-HandlePromotionFailure` 是否设置（一般都会打开，1.6 后被废弃），若已经设置，**进一步判断老年代可用内存大小，是否大于之前每一次 YGC 后进入老年代的对象的平均大小**，若老年代内存不够，或`-XX:-HandlePromotionFailure` 参数未设置，此时直接触发一次 FGC，对老年代进行垃圾回收，腾出空间，然后再次进行 YGC。

此时 YGC 可能出现：

1. YGC 后，**剩余存活对象的大小 小于 Survivor 区的大小**，此时存活对象进入 Survivor 即可；
2. YGC 后，**剩余存活对象的大小 大于 Survivor 区的大小，但 小于 老年代可用内存大小**，此时直接进入老年代；
3. 很不幸，YGC 后，**剩余存活对象的大小 大于 Survivor 区的大小，也 大于 老年代可用内存大小**，此时老年代无法存放这些存活的对象，就会发生“`Handle Promotion Failure`”的情况，此时就会触发 FGC（对老年代的垃圾回收，同时一般也会对新生代进行垃圾回收）。
4. 情况 3 中，最终 FGC 后，老年代仍没有足够的空间存放 YGC 后剩余的存活对象，此时就导致了 **OOM 内存溢出**。

JDK1.6 后废弃了 `-XX:-HandlePromotionFailure` 参数，生产一般不再设置该参数。

#### 空间分配担保机制

对老年代的空间进行担保。在发生 YGC 前，JVM 检查**老年代最大可用的连续空间是否大于新生代所有对象的总空间**

+ 若大于，则此次 YGC 是安全的。
+ 若小于，则 JVM 会查看`HandlePromotionFailure`设置值是否允许担保失败。
  + 若 `HandlePromotionFailure=true`，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，
    + 若大于，则尝试进行一次 YGC，但这次 YGC 依然是有风险的；
    + 若小于，则改为进行一次 FGC。
  + 若 `HandlePromotionFailure=false`，则只进行一次 FGC。

**空间分配担保原因**

因为新生代采用复制收集算法，假如大量对象在 YGC 后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而 Survivor 空间是比较小的，这时就需要老年代进行分配担保，把 Survivor 无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行 FGC 来让老年代腾出更多空间。

1.6 以后，只要判断 **老年代可用空间 > 新生代对象总和 ，或 老年代可用空间 > 历次 YGC 升入老年代对象的平均大小** ，两个条件满足一个，就直接进行 YGC，不需要提前触发 FGC 了。

以上 YGC 执行流程图

![Minor GC](../../../assets/垃圾回收机制/image-20210703205800345.png)

### 老年代垃圾回收算法

总结来说，老年代的触发垃圾回收机制（Full GC）的实际一般为两个：

1. 在 YGC 前，检查发现很可能 YGC 之后要进入老年代的对象太多，老年代放不下，此时需要提前触发 FGC 然后再带着进行 YGC。
2. YGC 后，发现剩余对象太多放入老年代都放不下了。

#### 标记整理法

首先标记出老年代中分散的对象，将存活的对象尽量挪动到一边，紧凑的靠在一起，以此避免内存碎片的产生。然后将剩余垃圾对象进行回收。

需要注意的是，老年代垃圾回收算法的速度至少要比新生代的垃圾回收算法的速度慢 10 倍。所以系统频繁出现 FGC，会导致系统性能被严重影响，出现频繁卡顿。

## JVM 优化

**尽量减少和避免 FullGC**

尽可能让对象都在新生代里分配和回收，别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，比如：

+ 给新生代中 Survivor 足够的空间，不要让在 Survivor 之间倒一次就可以回收的对象，进入到老年代，从而降低 FGC 的频率。

+ 或通过设置 `-XX:SurvivorRatio=8` 这个参数，缩小 Eden 空间比例，给 Survivor 区更多内存来防止动态年龄判断，防止存活对象直接进入老年代。

+ 同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。

+ 年轻代垃圾回收优化，看 Survivor 空间够不够。对任何系统，首先对内存使用模型预估以及合理的分配内存，尽量让每次 YGC 后的对象都留在 Survivor，不要进入老年代，这是首先要进行优化的一个地方。

### 触发 FullGC 的时机

**YGC 前：**

1. 年轻代对象大小 > 老年代可用内存 && 没开内存分配担保情况
2. 年轻代对象大小 > 老年代可用内存 && 开启内存分配担保情况，历次年轻代 GC 进入老年代大小平均值 > 老年代可用内存大小

**YGC 后：**

老年代放不下 GC 后存活的对象

### 避免 FullGC

1. 保证老年代可用空间大于新生代所有对象，避免 YGC 前进行 FGC。
2. 若 1 可以保证，那后面`-XX:HandlePromotionFailure`、进入老年代的对象平均大小等比较就不需要考虑了。
3. 尽量保证 YGC 后存活对象不大于 Survivor 空间。

### 避免年轻代对象进入老年代

1. 根据实际情况查看每次 YGC 后存活对象的大小，设置合适的 Survivor 区域大小，保证存活对象进入 survivor 区，而不是进入老年代
2. 根据对象存活的时间以及 YGC 的间隔时间，确定年龄。比如：3 分钟一次 YGC，而对象可以存活 1 个小时，那就把对象年龄设置到 20，避免对象 15 岁进入老年代
3. 大对象如果偶尔创建一个，可以设置`-XX:PretenureSizeThreshold`，使其分配至年轻代。如果创建销毁频繁，就让其直接进入老年代，利用对象池避免频繁创建销毁
4. 如果系统运算时间较长，导致对象的年龄比较大，可以适当调大 `-XX:MaxTenuringThreshold`，使对象年龄大一些再进入老年代，以减少进入老年代的对象

## 问题总结

2. 什么时候会触发 YGC
3. YGC 之后有哪几种情况对象会进入老年代
4. FGC 的算法是什么？
5. YGC 过后可能对应哪几种情况？
6. 如何检查老年代可用内存大小和历次 YGC 之后升入老年代的平均对象大小
7. 什么情况下 YGC 之前会提前触发 FGC
