---
title: JVM 内存模型
description: JVM 内存区域划分方法区、程序计数器、虚拟机栈、本地方法栈、堆内存及堆外内存。
toc: true
authors: 
    - WayneShen
tags: 
    - Java
    - JVM
categories: 
    - Java
series: []
date: '2020-04-21T14:45:+08:00'
lastmod: '2020-04-21T14:45:20+08:00'
draft: false
---

</br>

JVM 内存区域划分方法区、程序计数器、虚拟机栈、本地方法栈、堆内存及堆外内存。

<!--more-->

## JVM 内存区域划分

![JVM 内存区域划分](../../../assets/JVM内存模型/1.png)

### 方法区

JDK8 以前，方法区也叫永久代，主要用于存放 `class` 文件加载进来的类，也就是**类类型**和**常量池**等。必须指定大小限制。

JDK8 之后，该区域改为 **Metaspace**（元数据空间）。主要还是**存放应用程序中各种类的相关的信息**。可以设置大小，也可以不设置，无上限（受限于物理内存）。

**JDK8 中常量池放在了堆中**。

方法区，它会被垃圾回收，但需要全部满足以下条件：

1. 首先，该类的所有实例对象都已经从 Java 堆内存里被回收
2. 其次，加载这个类的 ClassLoader 已经被回收
3. 最后，对该类的 Class 对象没有任何引用

### 程序计数器

用于执行代码指令

```c
public java.lang.String getName(); 
descriptor: ()Ljava/lang/String; 
flags: ACC_PUBLIC
Code:
	stack=1, locals=1, args_size=1 
    0: aload_0
		1: get_field #2 
    4: areturn
```

上面是 class 中的字节码。比如 "0: aload_0" 就是一个**字节码指令**；

它对应了一条条的机器指令，计算机只有读到这种机器码指令，才知道具体要做什么。也就是告诉计算机做一些底层操作。

当 JVM 加载类信息到内存后，就会使用自己的字节码执行引擎，去执行代码编译出来的指令，在执行过程中 JVM 通过程序计数器**记录当前执行的字节码指令的位置**，即记录目前执行到哪一条字节码指令了。

同时 JVM 支持多线程，线程并发执行代码时，就会存在多个并发执行不同的代码指令。因此**每个线程都有自己的一个程序计数器**，专门记录当前线程目前执行到了哪一条字节码指令了。所以说**程序计数器是线程私有的**。

### 虚拟机栈

JVM 通过虚拟机栈这块内存区域来**保存每个方法内的局部变量等数据**，**每个线程独有自己的虚拟机栈，用来存放自己执行的那些方法的局部变量**。

当线程执行了一个方法，就会对这个**方法**创建对应的一个**栈帧**，并压入对应线程的虚拟机栈。栈帧里就有**该方法的局部变量表、操作数栈、动态链接、方法出口**等数据。方法执行完毕之后就出栈。

```java
public class A {
  
  public static void main(String[] args){
    B b = new B();
    b.load();
  }
}

public class B {
  
  private int count；
  
  public void load(){
    String param = "1";
  }
}
```

+ 首先执行 main 方法的线程，先创建 main 方法的栈帧并压入线程的虚拟机栈，并在栈帧中存放 b 这个局部变量。
+ 创建完对象 B 后，执行类 B 中的 load 方法，在方法中定义局部变量 param，并为 load 方法创建一个栈帧压入到主线程的虚拟机栈。此时栈帧的局部变量表中就会有 param 这个局部变量。
+ 当 load 方法执行完毕后，就会把 load 方法对应的栈帧从虚拟机栈中弹出。

### 堆内存

**存放代码中创建的各种对象实例**。

``new B() `` 即创建了 B 类的对象实例，对象实例中会包括一些数据。通过栈帧中的局部变量表，让一个引用类型的 b 局部变量来存放 B 对象的地址。即 b 指向了堆内存中的 B 对象实例。

### 本地方法栈

native 方法直接调用本地操作系统中的一些方法，一些 C 语言写的方法或一些底层类库。例如：``public native int hashCode()``。**在调用 native 方法时，就会有线程对应的本地方法栈**，这跟虚拟机栈类似，也是存放各种 native 方法的局部变量表之类的信息。

### 堆外内存

堆外内存不属于 JVM，通过 NIO 中的 allocateDirect 这种 API，可以在 Java 堆外分配内存空间。然后通过虚拟机里的 DirectByteBuffer 来引用和操作**堆外内存空间**。

很多技术都会用这种方式，因为**在一些场景下，堆外内存分配可以提升性能。**

## 线程对象内存模型

![线程对象内存模型](../../../assets/JVM内存模型/2.png)

线程的工作内存（CPU 级别的缓存）

![线程的工作内存](../../../assets/JVM内存模型/3.png)

## 扩展

**创建的对象在 Java 堆内存里到底会占用多少内存空间**

一个对象对内存空间的占用，大致分为两块：

+ 对象自己本身的一些信息 
+ 对象的实例变量作为数据占用的空间

比如对象头，如果在 64 位的 linux 上，会占用 16 字节，若实例对象内部有个 int 类型的实例变量，它会占用 4 个字节，若是 long 类型的实例变量，会占用 8 个字节。若是数组、Map 之类的，那么就会占用更多的内存。

另外 JVM 对这块有很多优化的地方，比如补齐机制、指针压缩机制等。