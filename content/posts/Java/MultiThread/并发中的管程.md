---
title: 并发中的管程
description: 管程，对应的英文是Monitor，也有将其直译成“监视器”。操作系统领域一般都翻译成“管程”，这个是意译。
toc: true
authors: 
    - WayneShen
tags: 
    - Concurrent
    - Java
    - Notes
categories: 
    - Java
series: []
date: '2020-05-01T23:50:+08:00'
lastmod: '2020-05-01T23:50:20+08:00'
featuredImage: ''
draft: false
---

管程，对应的英文是Monitor，也有将其直译成“监视器”。操作系统领域一般都翻译成“管程”，这个是意译。

<!--more-->

## 定义

Java采用的是管程技术，synchronized 关键字及 `wait()`、`notify()`、`notifyAll()` 这三个方法都是管程的组成部分。

而管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程更容易使用，所以Java选择了管程。

所谓管程，指的是**管理共享变量以及对共享变量的操作过程，让他们支持并发**。在Java领域的语言，就是**管理类的成员变量和成员方法，让这个类是线程安全的**。


## MESA模型

在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen模型、Hoare模型和 MESA模型。

Java管程的实现参考的是被广泛应用的MESA模型。

在并发编程领域，有两大核心问题：一个是**互斥**，即同一时刻只允许一个线程访问共享资源；另一个是**同步**，即线程之间如何通信、协作。

### 管程解决互斥问题

思路很简单，就是**将共享变量及其对共享变量的操作统一封装起来**

![img](../../../assets/并发中的管程/592e33c4339c443728cdf82ab3d318c4.png)

### 管程解决同步问题

在管程模型里，共享变量和对共享变量的操作是被封装起来的。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。

管程里还引入了条件变量的概念，而且每个条件变量都对应有一个等待队列，如下图，条件变量A和条件变量B分别都有自己的等待队列。

![img](../../../assets/并发中的管程/839377608f47e7b3b9c79b8fad144065.png)

举个例子，实现一个阻塞队列，有两个操作分别是入队和出队，出队的前提条件是队列不能为空，入队的前提条件是队列不能满，这两个方法都是先获取互斥锁，类比管程模型中的入口。

+ 对于入队操作，若队列已满，就需要等待直到队列不满，所以这里用了notFull.await();。

+ 对于出队操作，若队列为空，就需要等待直到队列不空，所以就用了notEmpty.await();。

+ 若入队成功，那么队列就不空了，就需要通知条件变量：队列不空notEmpty对应的等待队列。

+ 若出队成功，那就队列就不满了，就需要通知条件变量：队列不满notFull对应的等待队列。

### 阻塞队列实现

```java
public class BlockedQueue<T>{
  final Lock lock = new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull = lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty = lock.newCondition();
  // 入队
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){ 
        // 等待队列不满 
        notFull.await();
      }  
      // 省略入队操作...
      //入队后,通知可出队
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }

  // 出队
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }
      // 省略出队操作...
      //出队后，通知可入队
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}
```

其中，`await()` 和 `wait()` 语义是一样的；`signal()` 和 `notify()` 语义是一样的。

### wait() 如何使用

对于 MESA管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 `wait()`。这是 MESA 管程特有的。

```java
while(条件不满足) {
  wait();
}
```

Hasen模型、Hoare模型和 MESA模型的一个核心区别就是**当条件满足后，如何通知相关线程**。

管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行？

+ Hasen模型里，要求 `notify()` 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。

+ Hoare模型里，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但相比 Hasen模型，T2 多了一次阻塞唤醒操作。

+ MESA管程里，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里。这样做的好处是 `notify()` 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行时，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。

### notify()何时可以使用

除非经过深思熟虑，否则尽量使用 `notifyAll()`。使用`notify()`，需要满足以下三个条件:

1. 所有等待线程拥有相同的等待条件；
2. 所有等待线程被唤醒后，执行相同的操作；
3. 只需要唤醒一个线程。


## 参考资料

《Java并发编程实战》



> 本博客文章除特别声明外均为原创，采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 许可协议</a>进行许可。超出<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 许可协议</a>的使用请联系作者获得授权。