---
title: Java 内存模型
description: 从理论方面分析 Java 内存模型，以及其解决了线程安全的问题的原理。
toc: true
authors: 
    - WayneShen
tags: 
    - Concurrent
    - Java
    - Notes
categories: 
    - Java
series: []
date: '2020-05-01T23:11:+08:00'
lastmod: '2020-05-01T23:11:20+08:00'
featuredImage: ''
draft: false
---

</br>
从理论方面分析 Java 内存模型，以及其解决了线程安全的问题的原理。

<!--more-->

## 定义

Java 内存模型（Java Memory Model）的定义是通过 **动作**（actions）的形式进行描述的，所谓动作，包括变量的读和写、监视器加锁和释放锁、线程的启动和拼接（join）。  是保证 Java 程序在各个平台下都能保证效果一致的机制和规范。

JMM 本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

本质上可以理解为，JMM 规范了 JVM 如何提供按需禁用缓存和编译优化的方法。这些方法包括 volatile、synchronized 和 final 三个关键字，以及八项 Happens-Before 规则。

核心价值就是，解决了 **有序性** 和 **可见性**。

### 相关定义

#### 主内存

即堆空间，存储 Java 实例对象，包括成员变量、类信息、常量、静态变量等。

属于数据共享的区域，多线程并发操作时会引发线程安全问题。

#### 工作内存

即本地内存，或线程栈，存储当前方法的所有本地变量信息，字节码行号指示器、Native 方法信息。本地变量对其他线程不可见。

属于线程私有数据区域，不存在线程安全问题。

#### 两者存储类型及操作方式

方法里的基本数据类型，本地变量将直接存储在工作内存的栈帧结构中。

引用类型的本地变量，则是其引用存储在工作内存中，而具体的实例存储在主内存中。

对象的成员变量、static 变量、类信息均会被存储在主内存中。

主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存。

### JMM 与 Java 内存结构

两者是不同的概念层次

JMM 描述的是一组规则，通过这组控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM 是围绕原子性、有序性及可见性展开的。

两者相似点是，存在共享数据区域和私有数据区域。

### JMM 规范核心

主要是通过 **内存屏障**（memory barrier）禁止重排序，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。

对于编译器，内存屏障将限制它所能做的重排序优化。

对于处理器，内存屏障将会导致缓存的刷新操作。比如，编译器将在 volatile 字段的读写操作前后各插入一些内存屏障。

下图展示 JVM 内存模型，JVM 的内存模型只局限于内存中（JVM 内存中）。

![image-20210401000034874](../../../assets/Java内存模型/image-20210401000034874.png)

![image-20210401000254963](../../../assets/Java内存模型/image-20210401000254963.png)

多个线程调用了同一个对象的同一属性，他们都拥有了该属性的私有拷贝。

对于硬件而言，线程栈和堆存放在主内存中，部分线程栈和堆可能出现在 CPU 缓存或寄存器中。

![image-20210401001024246](../../../assets/Java内存模型/image-20210401001024246.png)

线程的工作内存（本地内存）只是抽象概念，涵盖了缓存，写缓冲区，寄存器等其他硬件和编译器优化，工作内存中存储了共享变量的副本。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于高速缓存及寄存器中。

## volatile

volatile 关键字并非 Java 语言独有，C 语言也有，它最原始的意义就是 **禁用 CPU 缓存**。

volatile 是 JVM 提供的轻量级同步机制。JVM 保证 volatile 修饰的共享变量对所有线程总是可见的。也就是告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或写入。

在 JDK1.5 后，对 volatile 语义进行了增强，主要就是 Happens-Before 规则。

### 为什么使用 volatile

能够保证 volatile 变量的可见性（不能保证 volatile 变量复合操作的原子性，如 i++）。

可见性的根本原因就是 **高速缓存的引入** 和 **重排序**。

### 解决内存可见性

volatile 有两个机制：**内存屏障** 和 **禁止指令重排序**。

简单来说，通过内存屏障，保证特定操作的执行顺序，同时保证某些变量的内存可见性。

对于 volatile 修饰的变量，执行写操作时，JVM 会发送一条 **lock 前缀** 的指令（CPU 的缓存锁）给 CPU，CPU 在计算完后会立即返回这个值写到主内存，同时因为有 **MESI 缓存一致性协议**，所以各个 CPU 都会对总线进行嗅探自己本地缓存中的数据是否被别人修改了，若发现别人修改了某个缓存的数据，CPU 就会将自己本地缓存中的数据过期清除，然后当前 CPU 上执行的线程读取变量时，就会从主内存重新加载最新的数据了。

MESI 缓存一致性协议（x86），表达缓存行的四种状态

Modify；Exclusive（独占、排他）；Share；Invalid。

缓存一致性协议确保每个 CPU cache 之间缓存共享数据（共享变量副本）的一致性。其核心思想是，当某个 CPU 在写数据时，如果发现操作的变量是共享变量，则会通知其他 CPU 告知该变量的缓存行是无效的，因此其他 CPU 在读取该变量时，发现其无效会重新从主存中加载数据。

### 适用场景

在中间件系统中，可能存在通过 volatile 关键字修饰变量，通过多线程关闭组件（否则组件在其他线程中一直存在，通过 while(param)）。

要在多线程中安全的使用 volatile 变量，必须同时满足：

1. 对变量的写入操作不依赖其当前值，或者说只是单纯的变量赋值

   + 不满足：`number++`、`count = count * 5`等
   + 满足：如 `boolean flag = true`

2. 该变量没有包含在具有其他变量的不变式中，不同的 volatile 变量之间不能互相依赖。

   只有在状态真正独立于程序内其他内容时才能使用 volatile。

32 位 Java 虚拟机里，对 `long/double` 变量的赋值写不是原子的，加上 volatile，可以保证原子性。像 `int i = 0` 的原子性是 Java 语言规范的。

### 注意事项：

1. **不要将 volatile 用在 getAndOperate（该场合不原子，需要再加锁）场合，volatile 适合仅仅 set 或 get 的场景**。

   如 `i = x * y`，需要先分别将 x 和 y 从主内存加载到工作内存，再从工作内存加载出来在 CPU 中执行，计算后的结果写回工作内存，再从工作内存里把 i 最新的值写回主内存。整个过程不是原子的。

   使用锁或 Atomic 可以保证原子性，Atomic 是基于 CAS 的乐观锁，当最终写入时进行 CAS 操作，可以保证原子性。

2. Java 内存模型允许 JVM 将没有被 volatile 修饰的 64 位数据类型的读写划分为两次 32 位的读写操作来进行（例如 double 和 long）。就会导致可能会出现读取到"半个变量"的情况。通过加上 volatile 解决该问题。

## final

除了使用 volatile 来禁用缓存以及编译优化，还可以使用 final 修饰变量，也就是告诉编译器：该变量生而不变，可以随便优化。当然 JDK1.5 后，Java 内存模型对 final 类型变量的重排进行了约束。只要正确的构造函数没有“逸出”，就不会有问题。

“逸出”有点抽象，在下面例子中，在构造函数里将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程通过 global.obj 读取 x 有可能读到 0 的。因此一定要避免“逸出”。

```java
final int x;
// 错误的构造函数
public FinalFieldExample() {
     x = 3;
     y = 4;
     // 此处就是讲 this 逸出，
     global.obj = this;
}
```

## 内存屏障

有三种屏障，读屏障（load barrier）、写屏障（wirte barrier）、全屏障（full barrier）。

### 实现禁止指令重排序

屏障的作用就是 **禁止两侧的指令重排序** 和 **强制刷数据到主内存**。

+ 通过在 **写操作** 后加入一条 **store** 屏障指令，让变量的值能刷新到主内存中；

+ 通过在 **读操作** 前加入一条 **load** 屏障指令，及时读取到变量在主内存的值。

### Java 中的内存屏障

+ LoadLoad 屏障：对于这样的语句 `Load1; LoadLoad; Load2`，在 Load2 及后续读操作要读取的数据被访问前，保证 Load1 要读的数据被读取完毕。
+ StoreStore 屏障：对于这样的语句 `Store1; StoreStore; Store2`，在 Store2 及后续写操作执行前，保证 Store1 的写入操作对其它处理器可见。
+ LoadStore 屏障：对于这样的语句 `Load1; LoadStore; Store2`，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。
+ StoreLoad 屏障：对于这样的语句 `Store1; StoreLoad; Load2`，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。**它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能**。

### volatile 语义的内存屏障

+ 在每个 volatile 写操作前插入 StoreStore 屏障（禁止普通写和 volatile 写重排序），在写操作后插入 StoreLoad 屏障（防止 volatile 写和之后可能的 volatile 读/写重排序）；
+ 在每个 volatile 读操作前插入 LoadLoad 屏障（禁止之后的读与 volatile 读重排序），在读操作后插入 LoadStore 屏障（禁止后面的写操作和之前的 volatile 读重排序）；

### final 语义的内存屏障

+ 新建对象过程中，构造体中对 final 域 的初始化写入和这个对象赋值给其他引用变量，两个操作不能重排序；
+ 初次读包含 final 域 的对象引用和读取，这两个操作不能重排序。

## Happens-Before 规则

含义：前面一个操作的结果对后续操作是可见的。也就是说，Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但要求编译器优化后一定遵守 Happens-Before 规则。

如果两个操作不满足任意一个规则，则两个操作就没有顺序的保障，

主要包括以下八项。

### 程序次序规则

在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。比较符合单线程的思维：程序前面对某个变量的修改一定是对后续操作可见的。

一段代码在一个线程中执行的结果是有序的。注意只是执行结果。

### 锁定规则

对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。管程（synchronized）由编译器自动实现加锁与释放锁。

### volatile 变量规则

对一个 volatile 变量的写操作 Happens-Before 于后面对该变量的读操作；换而言之，对一个 volatile 变量的写操作相对于后续对这个变量的读操作可见。

### 传递规则

A happens-before B , B happens-before C，那么 A happens-before C。

这是 1.5 对 volatile 语义的增强，意义重大，juc 靠 volatile 解决了可见性问题。

### 线程启动规则

Thread 对象的 `start()` 方法 happens-before 于此线程的每一个动作；

主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动之前的操作。

### 线程中断规则

对线程 `interrupt()` 方法的调用 happens-before 于被中断线程的代码检测到中断事件的发生。

可以通过 `Thread.interrupted()` 方法检测到是否有中断发生。

### 线程终结规则

对线程 `interrupt()` 方法的调用 happens-before 于被中断线程的代码检测到中断事件的发生。（ `Thread.join()` 方法结束、`Thread.isAlive()` 的返回值等手段检测到线程已经终止执行。）

主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 `join()` 方法实现），当子线程 B 完成后（主线程 A 中 `join()` 方法返回），主线程能够看到子线程的操作。“看到” 指的是对共享变量的操作。也就是说，如果在线程 A 中，调用线程 B 的 `join()` 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 `join()` 操作的返回。

### 对象终结规则

一个对象的初始化完成 happens-before 于其 `finalize()` 方法的开始。

## 同步操作

### 同步的八种操作

> lock -> read -> load -> use -> assign -> store -> write -> unlock 

![image-20210331235502339](../../../assets/Java内存模型/image-20210331235502339.png)

**lock** 

锁定：作用于**主内存**的变量，把一个**变量标识为一条线程独占状态**。

**read**

读取：作用于**主内存**的变量，把一个变量值**从主内存传输到线程的工作内存**中，以便随后的 load 动作使用。

**load** 

载入：作用于**工作内存**的变量，它把 read 操作从主内存中得到的变量值**放入工作内存的变量副本**中。

**use**

使用：作用于**工作内存**的变量，把工作内存中的一个**变量值传递给执行引擎**。每当 JVM 遇到一个需要 **使用到变量的值的字节码指令** 时，执行该操作。

**assign**

赋值：作用于**工作内存**的变量，它把一个**从执行引擎接收到的值赋值给工作内存的变量**，每当 JVM 遇到一个需要 **给变量赋值的字节码指令** 时，执行该操作。

**store**

存储：作用于**工作内存**的变量，把**工作内存中的一个变量的值传送到主内存**中，以便随后的 write 的操作

**write**

写入：作用于**主内存**的变量，它把 store 操作**从工作内存中一个变量的值传送到主内存的变量**中

**unlock**

解锁：作用于**主内存**的变量，把一个**处于锁定状态的变量释放出来**，释放后的变量才可以被其他线程锁定

### 同步规则

+ 若要把一个变量从主内存中复制到工作内存，就需要按顺序地执行 read 和 load 操作，要把变量从工作内存中同步回主内存中就要按顺序地执行 store 和 write 操作。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行（会出现插入其他指令）。
+ 不允许 read 和 load，store 和 write 操作之一单独出现。
+ 不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变后必须同步到主内存中。
+ 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中（store）。
+ 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即对一个变量实施 use 和 store 操作之前，必须先执行过 assign 和 load 操作。
+ 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次。多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现。
+ 若对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值
+ 若一个变量事先没被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许 unlock 一个被其他线程锁定的变量。
+ 对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。

## as-if-serial

含义是：**不管如何重排序，对于单个线程的执行结果不能变**。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。

重排序分为 编译器级别（语言级别的内存屏障）和 CPU 层面（CPU 层面内存屏障，lock 指令）。

编译器并不是会对所有的指令进行重排序，存在数据依赖规则的就不会进行重排序（前者影响后者）。写后读、写后写、读后写，不会进行重排序。

## 参考资料

《Java 并发编程实战》
