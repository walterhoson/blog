---
title: 深入理解synchronized
description: 从底层基础原理上，了解管程 synchronized 的实现原理，以及常见的问题
toc: true
authors: 
    - WayneShen
tags: 
    - Concurrent
    - Java
    - Notes
categories: 
    - Java
series: []
date: '2020-05-02T10:10:+08:00'
lastmod: '2020-05-02T110:30:20+08:00'
featuredImage: ''
draft: false
---

</br>
从底层基础原理上，了解管程 synchronized 的实现原理，以及常见的问题和优化

<!--more-->

## 原理

JMM中 数据交互流程为：lock -> read -> load -> use -> assign -> store -> write -> unlock 。

synchronized 通过对 lock、unlock 对主内存与线程工作内存之间的数据交互进行控制。

+ lock 时，若线程工作内存中已有共享变量，先将工作内存中的变量清空。
+ unlock 前，先将工作内存中的变量同步到内存中。

每个 Java 对象都可以隐式的扮演一个用于同步的锁的角色：这些内置的锁被称为**内部锁**（intrinsic locks）或**监视器锁**（monitor locks）。

内部锁在 Java 中扮演了互斥锁（mutual exclusion lock，也称mutex）的角色，意味着**同一时刻只有一个线程可以进入同步代码块**，后面的线程必须等待或阻塞，知道当前线程自动释放锁。

需要注意的是，synchronized 关键字不属于方法声明的一部分，所以子类继承父类时，若父类有 synchronized 修改的方法，子类调用该方法是无法获得同步效果的。



## 解决的问题

synchronized是独占锁，没有获取内部锁的线程会被阻塞掉。即互斥，同一时刻只有一个线程可以进入同步代码块，保证了原子性、可见性。

### 可见性问题

volatile 关键字修饰的共享变量，在同步会主内存后，通过缓存一致性协议，将其他工作内存中的值全部置为失效。

而 synchronized 则是在 lock 时先刷新线程工作内存中的变量，并在 unlock 前同步回主内存中，以解决可见性问题。

### 原子性问题

synchronized 关键字，是通过 lock 和 unlock 进行了原子性操作。



### 底层原理

监视器（monitor），是真正的锁对象。

synchronized 的锁对象会关联一个 monitor。monitor 内部有两个重要的成员变量：

+ **owner**（拥有这把锁的线程）
+ **recursions**（记录线程拥有锁的次数）

JVM 线程执行到同步代码块时发现没有 monitor，则创建。当一个线程拥有monitor，其他线程只能等待。

#### monitor

##### monitorenter

抢占锁

线程抢占monitor，抢到后将 `monitor.owner` 改成当前对象，recursions 变为1（重入后recursions++）

##### monitorexit

释放锁

能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程，

执行 monitorexit 时会将 monitor 进入数 -1（`recursions - 1`），直到为0时，当前线程退出 monitor。

方法的结束处和异常处，JVM 保证每个 monitorenter 必须又对应的 monitorexit。

##### monitor竞争

通过 CAS 尝试把 monitor 的 owner 字段设置为当前线程。

- 若设置之前的 owner 指向当前线程，说明当前线程再次进入 monitor，即重入，执行 `recursions++`，记录重入次数。
- 若当前线程是第一次进入该 monitor，设置 `recursions=1`，_owner 指向当前线程，该线程成功获得锁并返回。
- 若获取锁失败，则等待锁的释放（进入 cxq 队列）。

##### monitor等待

EnterI 方法，当前线程被封装成 ObjectWaiter 对象 node，状态设置成 `ObjectWaiter::TS_CXQ` ，

在 for 循环中，通过 CAS 把 node 节点 push 到 _ cxq 队列中，同一个时刻可能有多个线程把自己的 node 节点 push 到 cxq 列表中。

node 节点 push 到 _cxq 队列后，通过自旋尝试获取锁，若还没有获取到锁，则通过 park（内核函数）将当前线程挂起，等待被唤醒。

当该线程被唤醒时，会从挂起的点继续执行，通过 `ObjectMonitor::TryLock` 尝试获取锁。

##### monitor释放

通过 exit 来释放，

退出同步代码块时会让 `_recursions-1`，直到减为 0 时，说明线程释放了锁，根据不同的策略（由 QMode 指定），

从 cxq 或 EntryList 中获取头节点，通过 `ObjectMonitor::ExitEpilog` 方法唤醒该节点封装的线程，唤醒操作最终由 unpark 完成。

##### 修饰同步方法

方法的 flag 上有个 ACC_SYNCHRONIZED 标志修饰，

JVM 会在执行方法前隐式的调用 monitorenter，在执行方法后调用 monitorexit。

### 重量级锁

park 和 unpark 是内核函数，属于重量级操作。

涉及到内核态和用户态的切换（之间通过**系统调用**，来操作内核提供的资源，如IO）。

#### 用户态与内核态

用户态程序将一些数据值放在寄存器中，或使用参数创建一个堆栈，以此表明需要操作系统提供的服务。

+ 用户态程序执行系统调用，CPU切换到内核态，并跳到位于内存指定位置的指令
+ 系统调用处理器（system call handler）读取程序放入内存的数据参数
+ 系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果

由此可见用户态切换到内核态需要传递很多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等（上下文），以备内核态切换回用户态。

这种切换就带来了大量的系统资源消耗。这就是 synchronized 在未优化之前，效率低的原因。



## JDK6的优化

在 JDK6 之前基于重量级锁。

### CAS（Compare and Swap）

CAS + volatile 可以实现无锁并发。

**CAS 在获取共享变量时，使用 volatile 保证变量可见性，实现无锁并发，适用于竞争不激烈、多核CPU的情况**。属于乐观锁。

没有 synchronized，线程不会陷入阻塞，不会涉及用户态与内核态的切换，提升效率。

若竞争激烈，CAS 重试（自旋）必然频繁发生，反而效率会受影响。

```java
//eg：（AtomicInteger）
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    return var5;
}
```

### 锁升级

无锁 -> 偏向锁 -> 轻量级锁 -> （进入适应性自旋） -> 重量级锁

### 对象的布局

#### 查看对象布局

引入 `org.openjdk.jol` （jol-core）

通过 `ClassLayout.parseInstance(obj).toPrintable()` 来查看对象布局。

#### 1. 对象头

对象头包括：Mark Word（标记字段）、Klass Point（类型指针）、数组长度（如果当前对象是数组）

##### Mark Word

64位虚拟机情况下是 64bit

从后往前，最后两位是**锁标志位**，最后第三位为**是否偏向锁（1是0否）**，倒数第4位到第7位表示**分代年龄**（4位），中间31位表示 **hashcode**。

|          | 25bit  | 31bit    | 1bit   | 4bit | Biased-lock 1bit | lock 2bit |
| -------- | ------ | -------- | ------ | ---- | ---------------- | --------- |
| 无锁     | unused | HashCode | unused | Age  | 0                | 01        |
| 偏向锁   |        |          | unused | Age  | 1                | 01        |
| 轻量级锁 |        |          |        |      |                  | 00        |
| 重量级锁 |        |          |        |      |                  | 10        |
| GC标志   |        |          |        |      |                  | 11        |

###### 偏向锁

64位虚拟机：JavaThread:54（当前线程指针）	epoch:2    unused:1    age:4    biased_lock:1    lock:2     

32位虚拟机下，JavaThread:23	epoch:2	age:4	biased_lock:1	lock:2    

###### 轻量级锁

指向线程栈中 lock record 指针（62bit）	00（lock）

###### 重量级锁

指向互斥量（重量级锁）的指针（62bit）	10（lock）

epoch：可以认为是时钟周期，因为偏向锁不存在撤销，所以通过时钟周期保证锁对象升级后，老的 epoch 无法获取新的 epoch 的偏向锁，说明他们不是同一时期的，就只能撤销偏向锁，并重新偏向。

##### klass pointer

Class 对象的类型指针，Jdk1.8 默认开启指针压缩后为4字节，关闭指针压缩（`-XX:-UseCompressedOops`）后，长度为8字节。其指向的位置是对象对应的 Class 对象（其对应的元数据对象）的内存地址。

#### 2. 实例数据

包括对象的所有成员变量，大小由各个成员变量决定，比如：byte占1个字节8比特位、int占4个字节32比特位。

#### 3. 对齐数据（填充）

可选，按8个字节对齐，仅仅为了起到占位符的作用。

由于 HotSpot 虚拟机的内存管理系统要求对象起始地址必须是8字节的整数倍，所以对象头正好是8字节的倍数。

因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

### 偏向锁

#### 原理

HotSpot 作者研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

当线程第一次访问同步块并获取锁时触发。vm 将会把对象头中的标志位设为”01“，即偏向模式。同时使用 CAS 在对象头的 Mark Word 和栈帧中的锁记录（Lock Record）里存储锁偏向的线程ID。

以后该线程进入和退出同步块时不需要再进行 CAS 操作来加锁与解锁，只需简单测试对象头的 Mark Word 里是否存储着指向当前线程ID指针（偏向当前线程）。

若测试成功，表示线程已经获得了锁，此时vm不需要任何同步操作，效率较高；若测试失败，则需要再测试一下 Mark Word 中偏向锁的标志是否设置成 01（当前为偏向锁），若没有设置，则使用 CAS 竞争锁；若设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。

#### 撤销

一旦有线程来竞争锁的时候触发撤销。

+ 偏向锁的撤销动作必须 **等待全局安全点**（某个时间点所有线程都停下来，无字节码正在执行），
+ 暂停拥有偏向锁的线程，判断偏向的线程是否存活，不存活则将对象头设为无锁状态，存活则拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁。
+ 唤醒暂停的线程。

#### 偏向锁的获得和撤销流程

 ![image-20210520100557454](../../../assets/深入理解synchronized/image-20210520100557454.png) 

#### 优点

1. 提高有同步但无竞争的程序性能。
2. **在只有一个线程执行同步块的时候进一步提高性能**，适用于一个线程反复获得同一个锁的情况
3. 很多线程竞争的时候，偏向锁反而会降低性能，因为撤销偏向锁会等待全局安全点。一般多个线程交替访问的情况可以关闭偏向锁。

#### 注意点

**偏向锁在1.6之后默认启用**，但在应用程序启动几秒钟之后才激活，可以使用 `-XX:BiasedLockingStartupDelay=0` 参数关闭延迟。

偏向锁会延迟 JIT 预热进程，并且偏向锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多并不会真正发生竞争的 synchronized 块时，才能体现出明显的改善。

若确定应用程序中所有锁通常情况下处于竞争状态，可以通过 `XX:-UseBiasedLocking=false` 关闭偏向锁，程序默认进入轻量级锁状态。

### 轻量级锁

轻量级是相对于使用 monitor 的传统锁而言。

#### 目的

在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗。

但若多个线程在同一个时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以他并非是用来代替重量级锁的。

#### 原理

##### 加锁

判断当前对象是否处于无锁状态（hashcode、0、01），若是则 JVM 首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，将锁对象的 Mark Word 复制到栈帧中的 Lock Record 中（定义名为 Displaced Mark Word），将 Lock Record 的 owner 指向当前对象。

JVM 利用 CAS 操作尝试将锁对象的 Mark Word 更新为指向 Lock Record 的指针，若成功表示竞争到锁并将标志位变为00，表示轻量级锁，执行同步操作；若失败则表示其他线程竞争锁，当前线程变尝试使用自旋来获取锁。判断当前锁对象的 Mark Word 是否指向当前线程的栈帧，是表示当前线程持有当前对象的锁，直接执行同步块，否则说明锁对象被其他线程抢占了，轻量级锁膨胀为重量级锁，锁标志位置为0，后面几个等待的线程进入阻塞状态。

##### 释放（解锁）

取出获取轻量级锁保存在 Displaced Mark Word（栈帧中的Lock Record）中的数据，用 CAS 操作将取出的数据替换回当前锁对象的 Mark Word 中，

若成功，说明没有竞争发生，释放成功；

若 CAS 失败，说明有其他线程争夺锁，需要将轻量级锁升级（膨胀）为重量级锁。

##### 轻量级锁及膨胀流程图

 ![image-20210520100557454](../../../assets/深入理解synchronized/image-20210520100557454.png) 

#### 优点

对于大部分锁不存在竞争，所以在多线程交替执行同步块的情况下，可以提升性能。

如果打破这个依据，则除了互斥的开销，还有大量 CAS 操作，因此**在多线程竞争的情况下，轻量级锁比重量级锁更慢**。

### 自旋锁

同步块执行时间较短，外面的线程进入阻塞状态花的时间相对来说比在外面自旋等待的时间要更多。

因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。

当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

#### 使用条件

CPU是多核的 && 同步块执行的时间较短

#### 使用方法

JDK1.4.2 就有了，但需要 `-XX:UseSpinning` 来开启。1.6之后默认开启。

默认自旋十次，可以通过 `-XX:PreBlockSpin` 更改次数。

JDK1.6 引入自适应自旋锁：通过前一次在同一个锁上自旋的时间及拥有者的状态来决定。

### 重量级锁

核心就是对象监视器，每个对象都有 ObjectMonitor，阻塞基于 MutexLock（互斥锁）monitorEnter 和 monitorExit。 

### 锁消除

虚拟机即时编译器 JIT 运行时，对一些代码上要求同步，但被检测出不可能存在共享数据竞争的锁进行消除。

主要判断依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把他们当作栈上数据对待，认为他们是线程私有的，同步加锁自然就无须进行。

### 锁粗化

JVM 探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。

### 降级

`Biased lock revocation`，当 JVM 进入安全点 SafePoint 时，会检查是否有闲置的 Monitor，然后试图进行降级。

### 优缺点对比

| 锁       | 优点                                                         | 缺点                                           | 适合场景                             |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ------------------------------------ |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场量     |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应离度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间<br>同步块执行速度非常快 |
| 重量级锁 | 线程竞争不适用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量<br>同步块执行速度较长     |



## 特性

### 可重入

同一个线程可以多次执行同一个synchronized代码块，重复获取同一把锁。

#### 实现原理

内部锁对象中会有一个计数器（recursions变量）记录线程获取锁的次数，在执行完一个同步代码块时，计数器减一，直到计数器的数量为0，则释放锁。

#### 优点 

+ 可避免死锁
+ 方便进行代码的封装

### 不可中断

当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后一个线程一直阻塞或等待，不可被中断。

在 ReentrantLock 中，`Lock.lock()` 也是不可中断的，可以使用 `Lock.tryLock()`，实现可中断。



## 使用方式

### 修饰代码块

```java
public void method(Object obj)
  synchronized (obj) {
    // 受保护的对象  
  }
}

public void method2()
  synchronized (this) {
    // 受保护的对象  
  }
}
```

同步大括号中的代码块，作用于调用的对象，锁传入的 obj 对象。

若传入this，表示锁住当前实例对象（即方法调用者）。

### 修饰方法

```java
public synchronized void method(String value) {
  // 方法内容
}
```

同步整个方法，作用于调用的对象（即方法调用者），也就是当前实例对象。

### 修饰静态方法

```java
public synchronized static void method() {
   // todo
}
```

同步整个静态方法，作用于这个类的所有对象（类对象），即锁类。

### 修饰类

```java
synchronized (A.class) {
  System.out.println("haha");
}
```

同步括号中的代码块，作用于所有对象（类对象），属于A的类对象的锁。



## 实战优化

### 减少synchronized范围

同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。

执行时间较短也可能用轻量级锁、自旋锁就可以完成，避免升级到重量级锁。

### 降低synchronized锁的粒度

将一个锁拆分成多个锁来提高并发性能，不要对两段无关的代码加同一个对象锁。

优化示例1：HashTable和ConcurrentHashMap

HashTable：锁定整个Hash表，一个操作正在进行，其他所有操作也同样锁定，效率低下。

ConcurrentHashMap：局部锁定，只锁定桶。当对当前元素锁定时，其他元素不锁定（桶里没有元素，通过CAS操作；若有元素，在往后加时，通过 synchronized 锁定在第一个元素）。

优化示例2：LinkedBlockingQueue 入队和出队使用不同的锁，相对与读写只有一个锁效率更高。

### 读写分离

读取不加锁，写入和删除时加锁。

优化示例：ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteSet



## 与JUC中的锁对比

synchronized：不可中断锁，适合竞争不激烈，可读性好

Lock：可中断锁，多样化同步，竞争激烈时能维持常态

Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值



## 参考资料

《Java并发编程之美》

《Java并发编程实战》




> 本博客文章除特别声明外均为原创，采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 许可协议</a>进行许可。超出<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 许可协议</a>的使用请联系作者获得授权。
