---
title: 分布式事务架构设计本质
description: 
toc: true
authors: 
    - WayneShen
tags: 
    - Distributed
    - Theory
categories: 
    - Distributed
series: []
date: '2021-03-06T16:21:+08:00'
lastmod: '2021-03-06T16:22:20+08:00'
featuredImage: ''
draft: true
---

</br>

解析分布式事务架构的设计本质

<!--more-->

### 场景及问题

所有架构问题都是耦合性问题，耦合性问题可以通过拆分来解决。

分布式事务会将业务复杂化，能不使用分布式事务，尽量不使用。比如用户注册等场景。

分布式事务分为同步场景与异步场景。

### 方法论

#### 拆分

+ 分布式事务 -> 长事务

+ 本地事务 -> 短事务

+ 长事务拆分多个短事务

#### 补偿

A->B->C

+ A、B 成功，C 失败（重试多次仍失败）。C 不需要补偿（同步/异步补偿），通过逆向方式补偿 B 和 A。

场景一：多 DB

场景二：DB 和缓存（Redis）    
    Redis Set NX PX 命令在指定的 key 不存在时，为 key 设置指定的指
    set key value NX PX milliseconds 设置成功，返回 OK，设置失败，返回 NULL。
    由于 setNX 和 设置 EXPIRE key seconds，两个合起来，就非原子性了，那就需要修改 lua 脚本，增加了复杂度
    但如果 redis 仅仅作为缓存，不作为存储，那无需考虑事务，插入失败了大不了下次继续从 DB 获取。

场景三：DB 和 MQ

场景四：DB 和搜索（ES）

场景四：DB、MQ、缓存

### 场景分析

#### 异步场景

购买商品

+ 同步场景：扣减库存，建立订单；前台支付

+ 异步场景：前台超市未支付。通知用户

用户下单，先保存到订单库，同时发送一个订单未支付的延时消息给 MQ，比如 5min，5min 之后，MQ 通知后端服务，校验支付状态，若未支付，则取消订单

#### 解决方案

2PC

+ 应用程序发起事务 Commit 请求
+ 事务协调者发起 Prepare 投票。
+ 事务参与者都同意后，事务协调者再发起 Commit。
+ Commit 过程出现宕机等异常，服务重启后，再次进行 Commit。

两阶段提交仅适用于提交步骤比较少的场景，如果链路过长，效率太低。

利用消息队列的事务消息。

需要 MQ 支持事务消息，业务方需要提供回查接口。

方案二：

第一阶段消息落地数据库，将业务数据和消息保存本地事务。
第二阶段发送 MQ，从消息表获取数据发送给 MQ，失败则不断重试。

![image-20210701155338661](../../assets/分布式事务架构设计本质/image-20210701155338661-5126021.png)

https://github.com/apache/servicecomb-saga-actuator
