---
title: 分析缓存与数据库一致性的问题
description: 主要分析应用程序中缓存与数据库一致性的问题。
toc: true
authors: 
    - WayneShen
tags: 
    - Design
    - Solution
categories: 
    - Design
series: []
date: '2021-08-06T22:00:+08:00'
lastmod: '2021-08-06T22:00:20+08:00'
draft: false
---

</br>

主要分析应用程序中缓存与数据库一致性的问题，以及解决方案。

<!--more-->

首先声明没有银弹。没有场景，就没有最佳解决方案。

## 更新缓存的 Pattern

### Cache Aside

Facebook 采用这种策略。

+ 失效：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
+ 命中：应用程序从 cache 中取数据，取到后返回。
+ 更新：先把数据存到数据库中，成功后，再让缓存失效。

好处是，因为没有删除操作，先更新数据库，此时缓存依然有效，并发查询拿到的是没有更新的数据，但更新操作立马就让缓存失效了，后续的查询需要从数据库中重新查询，不会出现数据不一致。

没有在更新完数据库后，直接更新缓存，是因为可能存在并发更新时，导致缓存中出现脏数据。

但也存在问题，一个读操作没有命中缓存，然后到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的读操作再把老的数据放进去，此时造成了脏数据。

但是，实际上出现这个 case 的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还产生数据库锁，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。

### Read/Write Through

Cache Aside 是由调用方负责把数据加载入缓存，而 Read/Write Through 把更新数据库（Repository）的操作由缓存自己代理了。

可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的 Cache。

#### Read Through

Read Through 套路就是在查询操作中更新缓存，当缓存失效时（过期或 LRU 换出），Cache Aside 是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载，从而对应用方是透明的。

#### Write Through

Write Through 套路和 Read Through 相仿，不过是在更新数据时发生。当有数据更新时，若没有命中缓存，直接更新数据库，然后返回。若命中了缓存，则更新缓存，然后再由 Cache 自己更新数据库（这是一个同步操作）。

### Write Behind

又叫 Write Back，大概就是先更新缓存，背后批量去更新数据库等。最终一致性

Write Behind 又叫 Write Back。类似 Linux 文件系统的 Page Cache 的算法。

在更新数据时，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的 I/O 操作飞快无比（因为直接操作内存），因为异步，write backg 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。

但其带来的问题是，数据不是强一致性的，而且可能会丢失。在软件设计上，基本上不可能做出一个没有缺陷的设计，从来都是取舍 Trade-Off。

另外，Write Back 实现逻辑比较复杂，因为他需要 track 有哪数据是被更新了的，需要刷到持久层上。操作系统的 write back 会在仅当这个 cache 需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫 lazy write。

## 常见解决方案

### 先更新缓存，再写数据库

异常情况下，若更新缓存成功了，而修改数据库失败了，那么数据库中的是旧数据，缓存中为新数据，由于业务失败回滚，此时缓存中的也可以被称为脏数据，同时也产生了数据不一致，无法接受。

同时可以存在另一个问题，就并发更新数据库中同一条记录，可能存在因为网络问题，先更新数据库的线程后更新缓存，这也导致脏数据，也是无法接受的。

### 先更新数据库，再更新缓存

好处是，因为没有删除操作，就算更新数据库失败，缓存依然有效，不会影响到后面的读操作。

并发情况下，读取数据的请求，发现缓存中没有数据，去数据库中读取，此时更新操作进来先更新了数据库，再更新了缓存，而此时之前的读操作请求又把旧数据覆盖掉了新的缓存。

但这种更新库并更新缓存的耗时比另一个线程直接更新慢的情况很少见，首先数据库本身读比写要快许多。所以这种情况出现的概率较小。对于允许出现小概率不一致的情况可以使用这种方案。

### 先删除缓存，再更新数据库

当请求 A 进行更新操作删除了缓存，此时请求 B 正好进行查询，发现缓存不存在，则去数据库查询，拿到一个旧值，更新入缓存中，请求 A 继续执行将新值写数据库，成功后并更新缓存。

此时仍然存在短暂性的数据不一致，但也基于支持存在覆盖操作。

通过延时双删等方案，大概策略是，先淘汰缓存，在写数据库，与上面一致，之后更新操作前先休眠几秒，然后再次淘汰缓存并更新缓存。主要目的就是为了删除这几秒内的脏数据。

存在的缺点就是，实现复杂，同时休眠会导致响应变慢，也是无法接受的。延迟时间的设置也是比较头疼的，无法精确得出第一次淘汰缓存到最后更新缓存成功之间耗时多久。


## 参考资料

[Read-Through, Write-Through, Write-Behind, and Refresh-Ahead Caching](https://docs.oracle.com/cd/E15357_01/coh.360/e15723/cache_rtwtwbra.htm#COHDG5177)

[缓存更新的套路](https://coolshell.cn/articles/17416.html#ReadWrite_Through_Pattern)

