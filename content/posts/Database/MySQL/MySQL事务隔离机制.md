---
title: MySQL 事务隔离机制
description: 分析 MySQL 中的事务隔离机制，并分析事务隔离实现的原理。
toc: true
authors: 
    - WayneShen
tags: 
    - MySQL
    - Notes
categories: 
    - DataBase
series: []
date: '2020-08-28T21:30:+08:00'
lastmod: '2020-08-28T21:30:20+08:00'
draft: false
---

</br>

分析 MySQL 中的事务隔离机制，并分析事务隔离实现的原理。

<!--more-->

事务就是保证一组数据库操作，要么全部成功，要么全部失败。

MySQL 中，InnoDB 支持事务，MyISAM 引擎不支持事务。

## 隔离性与隔离级别

事务的四大特性：ACID（Atomicity、Consistency、Isolation、Durability）即原子性、一致性、隔离性、持久性。

SQL 标准的事务隔离级别：

+ **读未提交**（read uncommitted）：一个事务还没提交时，它的变更就能被别的事务看到。
+ **读提交**（read committed）：一个事务提交之后，它的变更才会被其他事务看到。
+ **可重复读**（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然未提交变更对其他事务也是不可见的。
+ **串行化**（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成才能继续执行。

实际上，数据库里面会创建一个视图（read-view），访问的时候以视图的逻辑结果为准。

+ 在**读未提交**下，直接返回记录上的最新值，没有视图概念。
+ 在**读提交**下，这个视图是在每个 SQL 语句开始执行的时候创建。
+ 在**可重复读**下，这个视图是在事务启动时创建，整个事务存在期间都用这个视图。
+ 在**串行化**下，直接用加锁的方式来避免并行访问，没有视图概念。

## 事务隔离的实现

同一条记录在系统中可以存在多个版本（MVCC，多版本的并发控制，Multi-Version Concurrency Control），每次更新的同时会记录一条回滚操作，即 undo log。记录上次的最新值，通过回滚操作可以得到前一个状态的值。

系统判断当没有事务再需要用到这些回滚日志时（当系统里没有比这个回滚日志更早的 read-view 时），就将该回滚日志被删除。

![undo log](../../../assets/MySQL事务隔离机制/undolog.png)

所以建议不要使用长事务，**长事务意味着系统里面会存在很老的事务视图**。由于这些事务随时可能访问数据库里面的任何数据，所以该事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

information_schema 库的 innodb_trx 表可以查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) > 60
```

可重复读隔离级别下，开启事务创建 read-view，过程中即使有其他事务修改了数据，当前事务仍然和启动时看到的数据一致。

### 视图

在 MySQL 里，有两个“视图”的概念：
+ view。它是一个用查询语句定义的虚拟表，在调用时执行查询语句并生成结果。创建视图的语法是 create view，而它的查询方法与表一样。
+ InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于 支持 RC（读提交）和 RR（可重复读）隔离级别的实现。它没有物理结构，用来在事务执行期间定义“我能看到什么数据”。

### 快照

在可重复读隔离级别下，事务在启动时就拍了个快照。这个快照是基于整库的。

InnoDB 里**每个事务有一个唯一的事务 ID，叫 transaction id**。是在事务开始时向 InnoDB 的**事务系统申请的，按申请顺序严格递增**。

而每行数据也都是有多个版本。每次事务更新数据时，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 **row trx_id**。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本 (row), 每个版本有自己的 row trx_id。 如图所示，就是一个记录被多个事务连续更新后的状态。

![row 更新过程](../../../assets/MySQL事务隔离机制/row-update.png)

图中三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要时根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 执行 U3、U2 算出来。

按照可重复读的定义，一个事务启动时，能够看到所有已经提交的事务结果。但之后，事务执行期间，其他事务的更新对它不可见。

因此，InnoDB 代码实现上，一个事务只需要在启动时，找到所有已经提交的事务 ID 的最大值，记为 up_limit_id（来源于源码里面的变量名）；然后声明 **如果一个数据版本的 row trx_id 大于 up_limit_id，就不认，必须要找到它的上一个版本**。当然，如果一个事务自己更新的数据，自己还是要认的。有了这个声明后，系统随后发生的更新，就跟这个事务看到的内容无关了。因为之后的更新，产生的新的数据版本的 row trx_id 都会大于 up_limit_id，而对它而言，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。

InnoDB 利用了 “所有数据都有多个版本” 的这个特性，实现了 “秒级创建快照” 的能力。

![可重复读下事务隔离查询](../../../assets/MySQL事务隔离机制/repeatableRead.png)

Q2 的读取：

+ 找到 (1,3) 的时候，判断出 row trx_id=101 大于 up_limit_id，要不起；
+ 接着，找到上一个历史版本，一看 row trx_id=102，还是要不起；
+ 再往前找，终于找到了 (1,1)，它的 row trx_id=90，是可以承认的数据。

事务 A 读到的这个数据，跟它在刚开始启动时读到的相同，也就是**一致性读**。

数据版本在没有被需要时被删除。如果只考虑图中的三个事务的话，事务 B 只需要访问到 (1,3) ，而事务 C 需要访问到的是 (1,2)。也就是说，在事务 A 提交后，(1,1) 这个版本就可以被删掉了。

### 当前读

更新操作是在最新版本上进行，否则中间的更新就消失了。有一条规则：**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读 (current read)”**。 除了 update 语句外，select 语句如果加锁，也是当前读。

所以，如果把 Q2 修改一下，加上 lock in share mode（读锁，也叫 S 锁/共享锁）或 for update（写锁，也叫 X 锁/排他锁），也都可以读到版本号是 101 的数据，返回的 k 的值是 3。

```sql
select k from t where id=1 lock in share mode; 
select k from t where id=1 for update;
```

+ 在可重复读隔离级别下，只需要在事务开始时找到那个 up_limit_id，之后事务里的其他查询都共用这个 up_limit_id。
+ 在读提交隔离级别下，每一个语句执行前都会重新算一次 up_limit_id 的值。

那么，在读提交隔离级别下，语句 Q1 和 Q2 返回的 k 的值，分别应该是多少呢？下面是读提交时的状态图，可以看到 Q1、Q2 语句的 up_limit_id 发生了变化。

![读已提交下事务隔离查询](../../../assets/MySQL事务隔离机制/readCommited.png)

这时，事务 A 的 Q2 语句开始执行时，由于事务 B(101)、C(102) 都已经提交了，所以 Q2 的 up_limit_id 的值就应该是事务 C 的 transaction id，即 102。那么，它在读到 (1,3) 时，就满足了 up_limt_id(102) ≥ row trx_id(101) 的条件，所以返回了 k=3。

### MVCC 特点

1. MySQL 中 InnoDB 引擎支持 MVCC
2. 应对高并发事务，MVCC 比单纯的加行锁更有效，开销更小
3. MVCC 在读已提交（Read Committed）和可重复读（Repeatable Read）隔离级别下起作用
4. MVCC 既可以基于乐观锁又可以基于悲观锁来实现

## undo log

首先数据库记录中，每一行记录都有两个隐藏列：**DATA_TRX_ID**、**DATA_ROLL_PTR**。（当然如果没有主键还有个隐藏主键）。

undo log 可以存储在一个或多个 undo 表空间中，而不是系统表空间中。

+ **DATA_TRX_ID：记录最近更新这条行记录的事务 ID，大小为 6 个字节**
+ **DATA_ROLL_PTR：表示指向该行回滚段（rollback segment）的指针，大小为 7 个字节，InnoDB 便是通过这个指针找到之前版本的数据。**

该行记录上所有旧版本，在 undo log 中都通过链表的形式组织。

### undo log 原理

undo log 只对事务本身可见，所以 insert 语句的 undo log 在事务提交后可以**直接删除**，无需执行 purge 操作。

update 中 undo log 为了实现 MVCC，不能在事务提交后立刻删除，需要**在事务提交时放入到 history list 上，等待 purge 线程进行最后的删除操作**。

delete 操作，实际的行记录也不会立刻删除，而是**在行记录头信息记录了一个 deleted_flag 标志位**，最终会**在 purge 线程 purge undo log 时进行实际的删除操作**，这时 undo log 也会清理掉。

![undo log](../../../assets/MySQL事务隔离机制/undolog-Row.png)

## 总结

InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的 up_limit_id。

普通查询语句是一致性读，一致性读会根据 row trx_id 和 up_limit_id 的大小决定数据版本的可见性。

+ 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
+ 对于读提交，查询只承认在语句启动前就已经提交完成的数据。

而当前读，总是读取已经提交完成的最新版本。

## 参考资料

《MySQL 45 讲》