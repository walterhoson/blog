---
title: MySQL 中 count 原理
description: 浅析 MySQL 中 count 的基本实现原理，以及不同的 count 方式之间的性能差异。
toc: true
authors: 
    - WayneShen
tags: 
    - MySQL
    - Notes
categories: 
    - DataBase
series: []
date: '2020-08-28T23:10:+08:00'
lastmod: '2020-08-28T23:10:20+08:00'
draft: false
---

</br>

浅析 MySQL 中 count 的基本实现原理，以及不同的 count 方式之间的差异。

<!--more-->

## count(*) 的实现方式

+ MyISAM 引擎把一个表的总行数存在了磁盘上，执行 `count(*)` 时会直接返回这个数，效率很高（有 where 条件也需要过滤）
+ InnoDB 引擎执行 `count(*)` 时，需要把数据一行一行地从引擎里面读出来，然后累积计数。

InnoDB 无法像 MyISAM 一样将数字存起来，因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。

MySQL 也做了优化。普通索引树叶子节点只存主键值，比主键索引树小，对于 `count(*)` 遍历哪个索引树得到的结果逻辑上都一样。因此，MySQL 优化器会找到最小的那棵树来遍历。

**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一**。

通过 ``show table status`` 结果中，也有 Rows 也用于表示表当前有多少行，但其实这个数据也是通过采样估算来的，所以也很不准，官方文档表示误差可能打到 40%-50%，所以不可用。

## 业务实现

如果有页面频繁要显示系统的操作记录总数，只能通过业务实现。

### 用缓存系统保存计数

缺点：

+ redis 等缓存不可靠，容易丢失更新，导致数据不一致；
+ 即使 Redis 正常工作，这个值还是逻辑上不精确的。因为在并发系统里，无法精确控制不同线程的执行时刻。
+ 不支持分布式事务，无法拿到精确一致的视图。

### 用数据库保存计数

把这个计数直接放到数据库里单独的一张计数表中。利用事务的原子性和隔离性，保持数据逻辑上的一致。

当然需要新更新业务数据，再更新计数表。因为计数表，更加容易产生行锁竞争，所以放在后面更新最大程度的减少事务间的锁等待，提升并发度。

## 不同 count 用法

`count()` 是聚合函数，对于返回的结果集，一行行地判断，若 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。

`count(*)`、`count(id)` 和 `count(1)` 都表示返回满足条件的结果集的总行数；

### `count(field)`

表示返回满足条件的数据行里面，参数 field 不为 NULL 的总个数。

+ 若 field 定义为 not null，一行行地从记录里面读出这个字段，判断不能为 null，直接按行累加；
+ 若 field 定义允许为 null，执行时，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

### `count(id)`

InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，因为主键 id 不可能为空，直接按行累加。

### `count(1)`

InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

`count(1)` 执行得要比 `count(id)` 快。因为**从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作**。

### `count(*)`

并不会把全部字段取出来，而是专门做了优化。`count(*)` 肯定不是 null，按行累加。即：不取值，直接累加

> 按照效率排序的话，`count(field)` < `count(id)` < `count(1)` ≈ `count(\*)`
> 尽量使用 `count(*)`。

## 参考资料

《MySQL 45 讲》