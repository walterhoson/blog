---
title: MySQL 基础架构
description: 分析 MySQL 中的基础架构，及相关执行流程。同时分析常见的数据库引擎的特性与差异。
toc: true
authors: 
    - WayneShen
tags: 
    - MySQL
    - Notes
categories: 
    - DataBase
series: []
date: '2020-08-28T20:00:+08:00'
lastmod: '2020-08-28T20:00:20+08:00'
draft: false
---

</br>

分析 MySQL 中的基础架构，及相关执行流程。同时分析常见的数据库引擎的特性与差异。

<!--more-->

![MySQL 基础架构](../../../assets/MySQL基础架构/Infrastructure.png)

## Server 层

包括：连接器、查询缓存、分析器、优化器、执行器

涵盖**大多数核心服务功能**，以及**所有的内置函数**（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如**存储过程、触发器、视图等**。

一条查询的SQL的执行链路大致为，从连接器连接，到查询缓存，再到分析器进行语法分析与词法分析，再进入优化器处理，选择认为效率最高的方案，最后通过执行器，调用存储引擎的API，进行查询操作。更新语句的大致流程也是如此。

### 连接器

执行语句时首先建立连接。**连接器负责跟客户端建立连接、获取权限、维持和管理连接**。

```shell
mysql -h$ip -P$port -u$user -p
```

建立连接之后开始认证身份

+ 用户名/密码错误，提示 “Access denied for user”，客户端程序执行结束。
+ 认证通过，**连接器回到权限表查询用户权限**，再依赖读到的权限数据，进行判断。所以在成功连接后，修改该用户权限，也不会影响已连接上的权限。修改后新建连接才会使用新的权限设置。

连接完成后，若没有后续动作，则连接处于空闲状态。使用 ``show processlist``  命令，`Sleep` 表示系统中的空闲连接。

客户端长时间没动静，连接器自动将其断开。时间参数通过 ``wait_timeout`` 控制，默认 **8h**。

若在连接被断开之后，客户端再次发送请求，会收到一个错误提醒：`Lost connection to MySQL server during query`。这时候若要继续，则需要重连，然后再执行请求。

建立连接过程通常比较复杂，所以建议在使用中要尽量减少建立连接的动作，也就是**尽量使用长连接**。

但**全部使用长连接**后，可能会发现，有时 **MySQL 占用内存涨得特别快**，这是因为 MySQL 在**执行过程中临时使用的内存是管理在连接对象里面**的。这些资源会在连接断开时才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

解决以上问题的方案：

+ **定期断开长连接**。使用一段时间，或程序里判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连；
+ 若使用的是 MySQL 5.7 或以上，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection` 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但会将连接恢复到刚刚创建完时的状态。

### 查询缓存

执行语句第二步：查询缓存

MySQL 拿到一个查询请求后，先查询缓存，之前是否执行过该语句。之前执行的语句及结果可能会以 key-value 对的形式，被直接缓存到内存中，key 是查询语句，value 是查询的结果。

+ 如果命中，直接返回给客户端。
+ 如果不命中，执行后续阶段，完成后，结果被存入查询缓存中。

但大多数情况**不建议使用查询缓存**，往往弊大于利。

由于只要有对一个**表的更新**，这个**表上的所有查询缓存都会被清空**。因此很有可能缓存的结果未使用，就被一个更新全清空了。对于更新压力大的库来说，查询缓存的命中率会非常低。除非业务就是一张静态表，很长时间才会更新一次。

MySQL 提供了**按需使用**，可以将参数 ``query_cache_type`` 设置成 **DEMAND**，这样默认 SQL 语句不适用缓存查询，而对于需要使用缓存查询的语句，可以使用 SQL_CACHE 显示指定

```sql
select SQL_CACHE * from T where ID=10;
```

注意：MySQL8.0 版本直接删除了查询缓存的整块功能。

### 分析器

若没有命中缓存，此时开始执行语句。

首先进行 SQL 语句进行 **词法分析**，识别关键字，select 识别为查询语句，识别表名等。

再进行 **语法分析**。根据词法分析结果，语法分析器根据语法规则，判断 SQL 语句是否满足 MySQL 语法。错误则收到 `You have an error in your SQL syntax` 的错误提醒。

经过了分析器，MySQL 就知道需要做什么了。

### 优化器

执行语句前，需要经过优化器处理。

优化器是在表里面有多个索引时，决定使用哪个索引；或在一个语句有多表关联 (join) 时，决定各个表的连接顺序。

最终选择执行效率高的执行方式。

### 执行器

执行语句前，先判断是否对表有执行权限，如 select 是否有查询权限，没有则返回没有权限错误。有则继续执行。

打开表时，优化器会根据表的引擎定义，去使用是这个引擎提供的接口。

比如，假设 ID 字段没有索引，

```sql
select * from T where ID = 10;
```

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，不是则跳过，是则将这行存在结果集中。
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

可以在数据库的慢查询日志中看到一个 `rows_examined` 的字段，表示这个语句执行过程中扫描了多少行。这个值就是**在执行器每次调用引擎获取数据行的时候累加**的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。

## 存储层

负责数据的存储和提取。架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。通过建表时使用 ``engine=memory`` 来指定。MySQL5.5.5 开始默认 InnoDB。

MySQL 上层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异。

### InnoDB

InnoDB 是 MySQL 的默认事务型引擎，也是使用最广泛的存储引擎。它被设计用来处理大量的短期 (short-lived) 事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 InnoDB 引擎。

InnoDB 表基于聚簇索引建立，聚簇索引对主键查询有很高的性能。不过它的二级索引 (secondary index, 非主键索引）中必须包含主键列，所以若主键列很大，其他的所有索引都会很大。因此，**若表上的索引较多，主键应当尽可能的小**。

InnoDB 采用 MVCC 来支持高并发，并实现了四个标准的隔离级别。其**默认级别是 REPEATABLE READ** （可重复读）, 并且**通过间隙锁 (next-key locking) 策略防止幻读的出现**。间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

InnoDB 内部做了很多优化，包括**从磁盘读取数据时采用的可预测性预读**，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引 (adaptive hash index), 以及能够**加速插入操作的插入缓冲区 (insert buffer)** 等。

### MyISAM

在 MySQL 5.1 及之前的版本，MyISAM 是默认的存储引擎。MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数 (GIS) 等，但 MyISAM **不支持事务和行级锁**，而且有一个毫无疑问的**缺陷就是崩溃后无法安全恢复**。但它绝不是一无是处，对于只读的数据，或表比较小、可以忍受修复 (repair) 操作，则依然可以继续使 用 MyISAM（但请不要默认使用 MyISAM, 而是应当默认使用 InnoDB)。

存储方面，MyISAM 会将表存储在两个文件中：**数据文件和索引文件**，分别以 .MYD 和 .MYI 为扩展名。MyISAM 表可以包含动态或静态（长度固定）行。MySQL 会根据表的定义来决定采用何种行格式。MyISAM 表可以存储的行记录数，一般受限于可用的磁盘空间，或操作系统中单个文件的最大尺寸。count 全表时不需要全表扫描了，直接返回结果。

在并发方面，MyISAM 会对整张表枷锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但在表有读取查询的同时，也可以往表中插入新的记录。

MyISAM 引擎也使用 B+ 树作为索引结果，叶节点的 data 域存放的是**数据记录的地址**，主索引要求 key 是唯一的，辅助索引的 key 可以重复。索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，若指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。MyISAM 的索引方式也叫做“非聚集”的，也是为了与 InnoDB 的聚集索引区分。

### Memory

若需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表（以前也叫做 HEAP 表）是非常有用的。Memory 表至少比 MyISAM 表要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘 I/O,Memory 表的结构在重启以后还会保留，但数据会丢失。

Memroy 表在很多场景可以发挥好的作用：
+ 用于查找 (lookup) 或映射 (mapping) 表，例如将邮编和地名映射的表。
+ 用于缓存周期性聚合数据 (periodically aggregated data) 的结果。
+ 用于保存数据分析中产生的中间数据。

Memory 表支持 Hash 索引，因此查找操作非常快。虽然 Memory 表的速度非常快，但还是无法取代传统的基于磁盘的表。Memroy 表是表级锁，因此并发写入的性能较低。它不支持 BLOB 或 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成 CHAR, 这可能导致部分内存的浪费（其中一些限制在 Percona 版本已经解决）。

如果 MySQL 在执行查询的过程中需要使用临时表来保存中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了 Memory 表的限制，或者含有 BLOB 或 TEXT 字段，则临时表会转换成 MyISAM 表。

## 参考资料

《MySQL 45 讲》

《高性能 MySQL》