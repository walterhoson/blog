---
title: MySQL 中的幻读与间隙锁
description: 浅析 MySQL 中的幻读以及间隙锁的原理。
toc: true
authors: 
    - WayneShen
tags: 
    - MySQL
    - Notes
categories: 
    - DataBase
series: []
date: '2020-08-29T00:30:+08:00'
lastmod: '2020-08-29T00:30:20+08:00'
draft: false
---

</br>

浅析 MySQL 中的幻读以及间隙锁的原理。

<!--more-->

## 幻读的定义

幻读指的是一个事务在前后两次查询同一个范围时，后一次查询看到了前一次查询没有看到的行。

+ 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据。因此，幻读在**当前读**下才会出现。**for update 就是当前读**。
+ sessionB 的修改结果，被 sessionA 之后的 select 语句用**当前读**看到，不能称为幻读。幻读仅专指**新插入的行**。

## 幻读存在的问题

### 语义上

一个事务先声明要把 `name = xx` 的行锁住，不准别的事务进行读写操作。若此时另一个事务 `insert name = xx` 或 `update name = xx` ，这是上个事务的语义被破坏了。

### 数据一致性

锁的设计是为了保证数据的一致性。一致性不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。t 表有三个字段 id，c，d。id 主键，c 有索引，d 没有索引。

初始化数据

```sql
insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

|     | session A                                                                              | session B                                                     | session C                                                     |
| --- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------- |
| T1  | begin;<br/>select * from t where d=5 for update; //Q1<br/>update t set d=100 where d=5 |                                                               |                                                               |
| T2  |                                                                                        | update t set d=5 where id=0;<br/>update t set c=5 where id=0; |                                                               |
| T3  | select * from t where d=5 for update; //Q2                                             |                                                               |                                                               |
| T4  |                                                                                        |                                                               | insert into t values(1,1,5);<br/>update t set c=5 where id=1; |
| T5  | select * from t where d=5 for update; //Q3                                             |                                                               |                                                               |
| T6  | commit;                                                                                |                                                               |                                                               |

执行完成后，数据库的结果。

1. 经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的 ;
2. 经过 T2 时刻，id=0 这一行变成 (0,5,5);
3. 经过 T4 时刻，表里面多了一行 (1,5,5);
4. 其他行跟这个执行序列无关，保持不变。

这些数据也没啥问题，但是再来看看此时 binlog 里面的内容。

1. T2 时刻，session B 事务提交，写入了两条语句；
2. T4 时刻，session C 事务提交，写入了两条语句；
3. T6 时刻，session A 事务提交，写入了 `update t set d=100 where d=5` 这条语句。

统一放到一起的话，就是这样的：

```sql
update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/
insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/
update t set d=100 where d=5;/* 所有 d=5 的行，d 改成 100*/
```

此时不论是拿到备库去执行，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。数据发生了不一致，很严重。

**即使把所有的记录都加上锁，还是阻止不了新插入的记录**，这就是幻读产生的主要原因。

## 如何解决幻读

产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。所以 innoDB 引入了间隙锁（Gap Lock）。锁住两个值之间的空隙，6 行数据就有 7 个间隙。

有了间隙锁，`select ** for update` 时，就不止是给数据库中已有的记录加上了行锁，还同时加了间隙锁。这样就确保了无法再插入新的记录。

**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作**，间隙锁之间不存在冲突关系，因为他们都是为了保护整个间隙。

注意：间隙锁必须是 update 操作，或 for update。**间隙锁是在可重复读隔离级别下才会生效**，读提交的话就没有间隙锁了，同时需要把 binlog 格式设置为 row，来解决数据和日志不一致问题。

间隙锁和行锁合成 next-key lock，每个 next-key lock 是前开后闭区间。如果用 `select * from t for update` 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25,+suprenum]。（InnoDB 给每个索引加了一个不存在的最大值 suprenum）

间隙锁和 next-key lock 的引入，解决了幻读的问题，但同时也带来了一些问题。可能会导致同样的语句锁住更大的范围，导致并发时容易死锁。

比如：sessionA 加上间隙锁，sessionB 也加上间隙锁，此时 B 执行 insert 操作，被 A 的间隙锁挡住了，A 执行同样的 insert 被 B 的间隙锁挡住。相互等待，形成死锁。当然，InnoDB 的死锁检测会马上就发现这对死锁关系，让 sessionA 的 insert 语句报错返回了。

### 间隙锁的原则

+ 有索引时，只会锁住该值前后两个区间（该行不存在时，锁住小于当前到大于当前的已存在的值的前开后闭区间）。
+ 唯一索引加锁做等值查询时，next-key lock 退化为行锁。
+ 唯一索引上的范围查询会访问到不满足条件的第一个值为止。就算此时在中间就可以判断终止了，可以认为是 MySQL 的 bug（8.0.18 已修复）。
+ 普通索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，next-key lock 退化为间隙锁。
+ 普通索引上的等值查询，如果加了 limit，向右遍历时，只需要扫描到满足的 limit 行数即停止。**在删除数据时尽量加 limit**，这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围
+ 无索引时会锁住所有的间隙，等于锁全表
+ 锁是加载索引上的，是 InnoDB 的基础设定
+ `lock in share mode` 若用上了覆盖索引，并不需要访问追加的那个索引，此时主键索引上没有加任何锁。所以如果使用 `lock in share mode` 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。

```sql
--- c 有 0，5，10，15，20，25
select * from t where c>=15 and c<=20 order by c desc lock in share mode;
```

1. 由于是 `order by c desc`，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。
2. 在索引 c 上向左遍历，要扫描到 `c=10` 才停下来（15 是满足条件的），为了防止 `c=10` 的行加入，需要锁定到索引 c 键（5,5），所以 next-key lock 会加到 (5,10]，这正是此时执行 `insert into t values(11,11,11)` 语句阻塞的原因。
3. 在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 `select *`，所以会在主键 id 上加三个行锁。

锁的范围是：索引 c 上（5，25），主键索引 id = 10，15，20

**用户 sql 的范围查询在 MySQL 内部会转成"对范围边界的等值查询"**

## 参考资料

《MySQL 45 讲》