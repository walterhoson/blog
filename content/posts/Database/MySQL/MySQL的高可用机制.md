---
title: MySQL 的高可用机制
description: 主要分析除了主备同步，保证最终一致性外，MySQL 还需要其他手段来保证高可用。
toc: true
authors: 
    - WayneShen
tags: 
    - MySQL
    - Notes
categories: 
    - DataBase
series: []
date: '2020-08-29T08:31:+08:00'
lastmod: '2020-08-29T08:31:20+08:00'
draft: false
---

</br>

主要分析除了主备同步，保证最终一致性外，MySQL 还需要其他手段来保证高可用。

<!--more-->

## 主备延迟

主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。

在主动切换场景下，有个”同步延迟“，与数据同步相关的时间点包括以下三个：

1. 主库 A 执行完成一个事务，写入 binlog，暂时把这个时刻记为 T1; 
2. 之后传给备库 B，把备库 B 接收完这个 binlog 的时刻记为 T2; 
3. 备库 B 执行完成这个事务，把这个时刻记为 T3。

**所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值**，也就是 T3-T1。

在备库上执行 `show slave status` 命令，返回结果就会显示 seconds_behind_master，就表示当前备库延迟了多少秒。

计算方法时这样的：

1. 每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；
2. 备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。其实就是 T3 - T1，这个值可以作为主备延迟的值，精度是秒。

主备库机器系统时间设置如果不一致，是不会导致主备延迟的值不准的。因为备库连接到主库时，会通过执行 `SELECT UNIX_TIMESTAMP()` 函数来获得当前主库的系统时间。若此时发现主库的系统时间与自己不一致，备库在执行 seconds_behind_master 计算时会自动扣掉这个差值。

需要说明的是，**在网络正常的时候，日志从主库传给备库所需的时间是很短的**，即 T2-T1 的值是非常小的。即**网络正常情况下，主备延迟的主要来源是备库接收完 binlog 和执行完这个事务之间的时间差**。

所以，**主备延迟最直接的表现是，备库消费中转日志 (relay log) 的速度，比主库生产 binlog 的速度要慢**。

### 主备延迟的来源

#### 主备机器性能差异

**在有些部署条件下，备库所在的机器性能比主库机器的性能差**。同步时，也依赖**备库的并行复制能力**。

但其实更新请求对 IOPS 的压力，主库和备库是无差别的。所以这种部署模式一般都会将备库设置为“非双 1”模式。

而实际上，**更新过程中也会有触发大量的读操作。所以备库机器上若有多个备库争抢资源就会导致主备延迟**。

当然这种部署方式现在比较少。因为主备发生切换，备库随时要变成主库，此时就需要对称部署了。

#### 备库压力大

即使在对称部署下，备库压力可能比主库还大。因为主库既然提供了写的能力，那么备库就可以提供读能力，或者运营后台的一些不能影响正常业务的分析语句。此时如果主库不克制使用而忽视备库压力，就会造成备库上的查询耗费大量 CPU 资源，影响同步速度，造成主备延迟。

所以处理逻辑可以为：

+ 一主多从，多个从库分担读的压力；
+ 通过 binlog 输出到外部系统，比如大数据平台，让外部系统提供统计查询能力。

其中一主多从应用广泛，因为从库更适合用来备份。

#### 大事物

主库上必须等事务执行完成才会写入 binlog，再传给备库。所以如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。比如一次性 delete 过多的数据。

大事物还包括**大表的 DDL**。


### MySQL 可靠性优先策略

双 M 结构下，主备切换一般由专门的 HA 系统完成，详细过程如下：

1. 判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步， 否则持续重试这一步；
2. 把主库 A 改成只读状态，即把 readonly 设置为 true;
3. 判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；
4. 把备库 B 改成可读写状态，也就是把 readonly 设置为 false;
5. 把业务请求切到备库 B。

在切换过程中存在不可用时间，即步骤 2-4，其中比较耗时的是步骤 3，这也是步骤一先判断间隔时间的原因。当然也可以通过修改为可用性优先策略将不可用时间将为 0。

### 可用性优先策略

切换时，先执行上述流程中的 4 和 5，那么就没有不可用时间了，但会造成数据不一致。

例如，在 `binlog_format = mixed` 下，原主库中插入的数据因为存在延迟，还在原备库的 relay log 中，并没有被应用，此时发生主备切换，若在现主库（原备库）中立刻插入一行新数据，并把这个 bin log 发给现备库（原主库），由于自增主键，此时主备库中的这两行数据因为插入的时机不同，导致了数据的不一致。

若 `binlog_format = row` 时，因为此时 binlog 中记录的是新插入行的所有字段值，所以最终只会有一行不一致，并且，两边主备同步的应用线程会报 duplicate key error 并停止。

得到结论，row 格式时，数据不一致的问题就很容易被发现，而 mixed 格式数据会悄悄不一致，等发现时已经不可查了，并连带着造成了更多数据的逻辑不一致。一般可靠性要优于可用性。除非主库出现了异常的情况，比如掉电，此时已经无法等到 sdm 小于 0 秒了，不立即切换则会导致服务不可用。

### 小结：

在满足数据可靠性的前提下，MySQL 高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。

## 参考资料

《MySQL 45 讲》