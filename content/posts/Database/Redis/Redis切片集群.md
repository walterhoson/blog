---
title: Redis 切片集群
description: 主要分析 Redis 切片集群的方案。
toc: true
authors: 
    - WayneShen
tags: 
    - Redis
categories: 
    - DataBase
series: []
date: '2021-07-31T18:00:+08:00'
lastmod: '2021-07-31T18:00:20+08:00'
draft: false
---

</br>

主要分析 Redis 切片集群的方案。

<!--more-->

数据增多，面临加内存还是加实例的选择，为了保存更多的数据一般有两种方案：

+ 纵向扩展（scale up）。升级单 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置 CPU。
+ 横向扩展（scale out）。横向增加当前 Redis 实例的个数。

纵向扩展中，一味的给 Redis 实例加内存，会导致持久化时 Redis 响应变慢。使用 RDB 对一个较大内存的 Redis 实例（32G 的机器 Redis 占用 25G）进行持久化时，通过 fork 子进程来完成，fork 操作的用时和数据量成正相关，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。若不要求持久化，纵向扩展是一个不错的选择。但此时又会有第二个问题，就是**纵向扩展会手硬件和成本的限制**。

横向扩展在 Redis 中就是**组建切片集群**，虽然组建比较麻烦，但对 Redis 主线程的阻塞影响较小。同时也不用担心单个实例的硬件和成本限制。**在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择**。

## 切片集群原理及使用

切片集群也叫做分片集群，就是指**启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存**。比如 25G 的数据平均分成 5 份（也可不均分），使用 5 个实例来保存，每个实例只需要存 5GB 的数据。

在切片集群中，为每个实例生成 RDB 数据量就小了很多，fork 子进程一般不会给主线程带来较长时间的阻塞。

采用集群方案，就需要解决多实例的分布式管理问题。包括数据分片后，如何在多个实例间分布；client 如何找到对应数据的实例

### 切片和实例的对应分布

实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前，官方并没有针对切片集群提供具体的方案。从 3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。Redis Cluster 方案中就规定了数据和实例的对应规则。

### Redis Cluster 方案

Redis Cluster 方案**采用哈希槽（Hash Slot）来处理数据和实例之间的映射关系**。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。

具体的映射过程分为两大步

1. 首先根据键值对的 key，按照 [CRC16 算法](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) 计算一个 16 bit 的值
2. 再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。

接下来需要解决哈希槽映射到具体的 Redis 实例的问题，在部署 Redis Cluster 时，可以使用 `cluster create` 命令创建集群，此时 Redis 会自动把这些槽平均分布在集群实例上。例如，若集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。

当然，也可以使用 `cluster meet` 命令手动建立实例间的连接，形成集群，再使用 `cluster addslots` 命令，指定每个实例上的哈希槽个数。假设集群中不同 Redis 实例的内存大小配置不一，若还是把哈希槽均分每个实例，在保存相同数量的键值对时，内存小的实例会比内存大的实例有更大的容量压力，这种情况下就需要根据不同资源配置使用 `cluster addslots` 来手动分配哈希槽。

下图展示数据、哈希槽、实例这三者的映射分布情况

![map-hashSlot](../../../assets/Redis切片集群/map-hashSlot.jpg)

图中的切片集群共三个实例，同时假设有 5 个哈希槽，首先可以通过一下命令手动分配哈希槽：实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存哈希槽 4。

```shell
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
```

在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 5 取模，再根据各自的模数结果，就可以被映射到对应的实例 1 和实例 3 上了。

需要注意，**在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作**。

### 客户端定位数据

在定位键值对数据时，它所处的哈希槽可以通过计算得到的，这个计算可以在客户端发送请求时来执行，此时要定位到实例，还需要知道哈希槽分布在哪个实例上。

一般而言，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但在集群刚刚创建时，每个实例只知道自己被分配了哪些哈希槽，并不知道其他实例拥有的哈希槽信息。Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会缓存到本地，当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。

但在集群中，实例与哈希槽的对应关系并非一成不变，最常见的变化有两个：

+ 在集群中，有实例新增或删除，Redis 需要重新分配哈希槽；
+ 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍

虽然实例间可以通过相互传递信息获取最新哈希槽分配信息，但客户端无法主动感知变化，这导致客户端缓存的分配信息与最新不一致了。Redis Cluster 方案提供了一种**重定向机制**，即，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据（该键值对映射的哈希槽），客户端要给一个新实例发送操作命令。首先该实例会先给客户端返回下面的 `MOVED` 命令作为响应结果，这个结果就包含了新实例的访问地址。

```shell
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
```

MOVED 命令表示，客户端请求的键值对所在和哈希槽 13320，也就是实例 172.16.19.5 上，通过返回的 MOVED 命令把哈希槽所在新实例信息告诉给客户端，此时客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。

![move](../../../assets/Redis切片集群/move.jpg)

若在 slot 迁移的过程中，由于 slot2 数据较多，只迁移了一部分到实例 3，此时客户端就会收到一条 ASK 报错信息：

```shell
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```

ASK 命令表示两次含义

1. 表明 Slot 数据还在迁移中
2. ASK 命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给最新实例发送 ASKING 命令，再发送操作命令。

上述例子中，ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但这个哈希槽正在迁移。此时客户端就需要先 172.16.19.5 实例发送一个`ASKING`命令，指的是，让个实例允许执行客户端接下来发送的命令，然后客户端再向该实例发送 GET 命令，以读取数据。

![asking](../../../assets/Redis切片集群/asking.jpg)

与 MOVED 命令不同，**ASK 命令并不会更新客户端缓存的哈希槽分配信息**。所以在上图中，若客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。

## 总结

切片集群在保存大量数据方面有优势，是基于哈希槽的数据分布机制和客户端定位键值对的方法实现。

在应对数据量扩容时，虽然增加内存这种纵向扩展的方法简单直接，但会造成数据库的内存过大，导致性能变慢。Redis 切片集群提供了横向扩展的模式，也就是使用多个实例，并给每个实例配置一定数量的哈希槽，数据可以通过键的哈希值映射到哈希槽，再通过哈希槽分散保存到不同的实例上。这样做的好处是扩展性好，不管有多少数据，切片集群都能应对。

另外，集群的实例增减，或是为了实现负载均衡而进行的数据重新分布，会导致哈希槽和实例的映射关系发生变化，客户端发送请求时，会收到命令执行报错信息。了解了 MOVED 和 ASK 命令

在 Redis 3.0 之前，Redis 官方并没有提供切片集群方案，但其实当时业界已经有了一些切片集群的方案，例如基于客户端分区的 ShardedJedis，基于代理的 Codis、Twemproxy 等。这些方案的应用早于 Redis Cluster 方案，在支撑的集群实例规模、集群稳定性、客户端友好性方面也都有着各自的优势。

## 参考资料

《Redis 设计与实现》

《Redis 核心技术与实战》