---
title: Redis 持久化-RDB
description: 主要分析 Redis 的持久化机制-RDB。
toc: true
authors: 
    - WayneShen
tags: 
    - Redis
categories: 
    - DataBase
series: []
date: '2021-07-31T15:00:+08:00'
lastmod: '2021-07-31T15:00:20+08:00'
draft: false
---

</br>

主要分析 Redis 的持久化机制-RDB。

<!--more-->

## AOF 与 RDB

用 AOF 方法进行故障恢复时，需要逐一把操作日志都执行一遍。若操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。

同时 Redis 提供了另一种持久化方法，**内存快照**。

所谓内存快照，就是**指内存中的数据在某一个时刻的状态记录**。Redis 中以文件的形式写在磁盘上，即使宕机，快照文件不会丢失，数据的可靠性就得到了保证。这个快照文件就被称为 RDB（Redis DataBase）文件。

与 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以在做数据恢复时，可以直接把 RDB 文件读入内存，很快地完成恢复。听起来很不错，但内存快照也并不是最优选项。

需要考虑两个关键问题：

+ 对哪些数据做快照？这关系到快照的执行效率问题；
+ 做快照时，数据是否能被增删改？这关系到 Redis 是否被阻塞，能否同时正常处理请求。

## 给哪些内存数据做快照

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是**全量快照**，也就是说，把内存中的所有数据都记录到磁盘中。这样做的好处是，一次性记录了所有数据。

给内存的全量数据做快照，全部写入磁盘也会花费很多时间。而且全量数据越多，RDB 文件就越大，往磁盘上写数据时间开销就越大。

Redis 的单线程模型决定了需要尽量避免所有会阻塞主线程的操作。所以需要了解生成快照是否会阻塞主线程。而 Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

+ save：在主线程中执行，会导致阻塞；
+ bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 **Redis RDB 文件生成的默认配置**。

所以**通过 bgsave 命令执行全量快照，既提供了数据可靠性，也避免了对 Redis 的性能影响**。

## 快照时数据是否可以修改

若在拍快照时，有数据发生了修改，那么就会破坏快照的完整性，所以一般在快照期间不希望数据修改。但若快照执行期间数据不能被修改，又存在潜在问题，因为此时无法动数据，给业务服务产生了巨大的影响。

为了快照而暂停写操作，显然不可接收。所以此时，Redis 就会借助 OS 提供的写时复制技术（Copy-On-Write），在执行快照的同时，正常处理写操作。简单而言，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并写入 RDB 文件。

此时若主线程对数据只进行读操作，那么主线程和 bgsave 子进程相互不影响。若主线程要修改一块数据，那么这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，所以这个过程中，主线程仍可以直接修改原来的数据。

这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免影响正常业务。

## 多久做一次快照

对于快照而言，**所谓“连拍”就是指连续地做快照**。此时快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。

**要想尽可能多的恢复完整的数据，时间间隔就要尽可能小**。虽然每次快照都由 bgsave 子进程在后台执行，也不会阻塞主线程。但若频繁的执行全量快照，会带来两方面的开销。

1. 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始了，容易造成恶性循环。
2. bgsave 子进程需要通过 fork 操作从主线程创建出来。**虽然子进程在创建后不会再阻塞主线程，但 fork 这个创建过程本身会阻塞主线程**，而且主线程的内存越大，阻塞时间越长。**若频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程**。

此时，可以做增量快照，**所谓增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录**，这样可以**避免每次全量快照的开销**。在做完全量快照后，只需要将被修改的数据写入快照文件，前提是需要记住哪些数据被修改了，需要使用额外的元数据信息去记录哪些数据被修改了，这又带来了额外的空间开销。

若将每一个键值对的修改都记录，数量较大时空间开销比较大，对于内存资源宝贵的 Redis 来说，得不偿失。

可以发现，**对于 AOF 相比，快照的恢复速度快，但频率不好把握。太低，一旦宕机可能丢失较多数据，太高，又会产生额外开销**。

## 混合方式

注意 Redis 4.x 以前开启AOF，会使默认 RDB 无效。重启通过 AOF 回滚。

Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。开启配置 `aof-use-rdb-preamble = yes`，RDB文件会以二进制的形式记录在 aof 文件的头部

**简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作**。

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

![mix](../../../assets/Redis持久化-RDB/mix.jpg)

此方法既能享受 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，颇有点“鱼和熊掌可以兼得”的感觉，建议使用。

## 小结

RDB 是避免数据丢失的内存快照。这个方法的优势在于，可以快速恢复数据库，也就是只需要把 RDB 文件直接读入内存，这就避免了 AOF 需要顺序、逐一重新执行操作命令带来的低效性能问题。

不过，内存快照也有它的局限性。它拍的是一张内存的大合照，不可避免地会耗时耗力。虽然，Redis 设计了 bgsave 和写时复制方式，尽可能减少了内存快照对正常读写的影响，但频繁快照仍然是不太能接受的。而混合使用 RDB 和 AOF，正好可以取两者之长，避两者之短，以较小的性能开销保证数据可靠性和性能。

最后，关于 AOF 和 RDB 的选择问题，三点建议：

- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
- 若允许分钟级别的数据丢失，可以只使用 RDB；
- 若只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。

## 一个小问题

曾有过这么一个场景：使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行 Redis，Redis 数据库的数据量大小差不多是 2GB，使用了 RDB 做持久化。当时 Redis 的运行负载以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100 个请求，80 个请求执行的是修改操作。在这个场景下，用 RDB 做持久化有什么风险吗？

+ 内存资源风险：Redis fork 子进程做 RDB 持久化，由于写的比例为 80%，那么在持久化过程中，“写实复制”会重新分配整个实例 80% 的内存副本，大约需要重新分配 1.6GB 内存空间，这样整个系统的内存使用接近饱和，如果此时父进程又有大量新 key 写入，很快机器内存就会被吃光，如果机器开启了 Swap 机制，那么 Redis 会有一部分数据被换到磁盘上，当 Redis 访问这部分在磁盘上的数据时，性能会急剧下降，已经达不到高性能的标准（可以理解为武功被废）。如果机器没有开启 Swap，会直接触发 OOM，父子进程会面临被系统 kill 掉的风险。
+ CPU 资源风险：虽然子进程在做 RDB 持久化，但生成 RDB 快照过程会消耗大量的 CPU 资源，虽然 Redis 处理处理请求是单线程的，但 Redis Server 还有其他线程在后台工作，例如 AOF 每秒刷盘、异步关闭文件描述符这些操作。由于机器只有 2 核 CPU，这也就意味着父进程占用了超过一半的 CPU 资源，此时子进程做 RDB 持久化，可能会产生 CPU 竞争，导致的结果就是父进程处理请求延迟增大，子进程生成 RDB 快照的时间也会变长，整个 Redis Server 性能下降。

## 参考资料

《Redis 设计与实现》

《Redis 核心技术与实战》