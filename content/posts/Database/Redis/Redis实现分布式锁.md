---
title: Redis 实现分布式锁
description: Redis 实现分布式锁的方案。
toc: true
authors: 
    - WayneShen
tags: 
    - Redis
categories: 
    - DataBase
series: []
date: '2021-08-01T06:00:+08:00'
lastmod: '2021-08-01T06:00:20+08:00'
draft: false
---

</br>

Redis 实现分布式锁的方案。

<!--more-->

## 分布式锁

在分布式场景下，锁变量需要由一个共享存储系统来维护，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值。

分布式锁的两个要求

1. 分布式锁的加锁和释放锁的过程，涉及多个操作。在实现时需要**保证这些锁操作的原子性**；
2. 共享存储系统保存了锁变量，若共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作。所以在实现时，需要考虑**保证共享存储系统的可靠性，进而保证锁的可靠性**。

## 单节点 Redis 实现分布式锁

首先赋予锁变量一个变量名，把这个变量名作为键值对的键，而锁变量的值，则是键值对的值，以此，Redis 就能保存锁变量了，客户端也就可以通过 Redis 的命令操作来实现锁操作。

因为 Redis 是单线程处理，所以即使两个客户端同时发送加锁请求，Redis 也会串行处理他们的请求。后执行的请求就会收到加锁失败的信息。

在保证操作原子性方面，有两种通用方法，一是 Redis 的**单命令操作**，二是**使用 Lua 脚本**。

### 单命令操作与 Lua 脚本

首先是 SETNX 命令，用于设置键值对的值，具体就是该命令在执行时会判断键值对是否存在，若不存在则设置键值对的值，若存在则不做任何处理。

在执行完业务逻辑之后，使用 DEL 命令删除锁变量。

```shell
# 加锁
SETNX lock_key 1
# 业务逻辑
do things
# 释放锁
DEL lock_key
```

使用 SETNX 和 DEL 组合实现分布式锁有两个潜在风险：

一是，假如某个客户端在执行了 SETNX 命令加锁之后，在处理业务数据时发生了异常，一直没有执行 DEL 命令来释放锁，此时就导致这个客户端一直占用锁，其他客户端无法拿到锁，也就无法执行后续的操作，阻塞了业务。

针对这个问题，一个有效的解决方法是，**给锁变量设置一个过期时间**。这样即使持有锁的客户端发生了异常，无法主动地释放锁时，Redis 也会在锁变量过期后把它删除，其他客户端就可以再次获取锁了。

Redis 对于 SET 命令也提供了 NX 的功能，同时也提供了过期时间的设置。

```shell
SET key value [EX seconds | PX milliseconds]  [NX]
# eg
SET lock_key unique_value NX PX 10000
```

二是，客户端 A 执行了 SETNX 命令加锁后，假设客户端 B 执行了 DEL 命令释放锁，此时，客户端 A 的锁就被误释放了。若客户端 C 正好也在申请加锁，就可以成功获得锁，进而开始操作共享数据。这样一来，客户端 A 和 C 同时在对共享数据进行操作，数据就会被修改错误，这也是业务层不能接受的。

针对这个问题，就需要区分来自不同客户端的锁操作。换而言之，就是在释放锁时，只能释放自己加的锁。

以下就是使用 lua 脚本（unlock.script）实现释放锁操作的源代码。

```js
//释放锁 比较 unique_value 是否相等，避免误释放。
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

KEYS[1] 表示 lock_key，ARGV[1] 是当前客户端唯一标志，这两个值是在执行 Lua 脚本时作为参数传入。最后释放锁的操作就如下

```shell
redis-cli --eval unlock.script lock_key, unique_key 
```

在释放锁时用到 lua 脚本，是因为释放锁逻辑中包含了读取锁变量、判断值、删除锁变量的多个操作，Redis **在执行 Lua 脚本时，可以以原子性的方式执行**，保证了释放锁操作的原子性。

## 多节点 Redis 实现分布式锁

单 redis 节点部署，一旦实例故障宕机，那么锁变量就丢失了，客户端也无法进行锁操作，进而影响了业务正常执行。多节点实现，是因为需要保证锁的可靠性。

实现高可靠的分布式锁，不能仅依赖单个的命令操作了，需要按照一定的步骤及规则进行加解锁，以避免 Redis 实例故障而导致锁无法工作的问题，即分布式锁算法。由 Redis 开发者 Antirez 提出了分布式锁算法 Redlock。

### 分布式锁 Redlock

Redlock 算法的基本思路，是**让客户端和多个独立的 Redis 实例依次请求加锁，若客户端能够和半数以上的实例成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁了，否则加锁失败**。

这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。

Redlock 算法的实现需要有 N 个独立的 Redis 实例。接下来可以分成 3 步来完成加锁操作：

1. 客户端获取当前时间。
2. 客户端按顺序依次向 N 个 Redis 实例执行加锁操作。每个实例加锁步骤与上面单实例操作一致，使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标志。保证某个实例故障时加解锁仍可用，需要对加锁设置设置超时时间。若客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。**加锁操作的超时时间需要远远地小于锁的有效时间**，一般也就是设置为几十毫秒。
3. 一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。客户端只有在满足以下两个条件时，才能认为加锁成功。
   1. 客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；
   2. 客户端获取锁的总耗时没有超过锁的有效时间。

满足上述第三部中的两个条件后，就需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。若锁的有效时间已经来不及完成共享数据的操作了，可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。

当然，如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那客户端向所有 Redis 节点发起释放锁的操作。

在 Redlock 算法中，释放锁的操作和在单实例上释放锁的操作一样，只需执行释放锁的 Lua 脚本即可。这样以来，只要 N 个 Redis 实例中的半数以上实例能正常工作，就能保证分布式锁的正常工作了。

在实际业务应用中，若想要提升分布式锁的可靠性，就可以通过 Redlock 算法来实现。

## 参考资料

《Redis 设计与实现》

《Redis 核心技术与实战》