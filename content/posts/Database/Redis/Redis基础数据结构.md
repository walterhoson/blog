---
title: Redis 基础数据结构
description: 主要分析 Redis 的五大基础数据结构构造，包括 string （字符串）、list （列表）、set （集合）、hash （哈希） 和 zset （有序集合）。
toc: true
authors: 
    - WayneShen
tags: 
    - Redis
categories: 
    - DataBase
series: []
date: '2021-07-31T11:10:+08:00'
lastmod: '2021-07-31T11:10:20+08:00'
draft: false
---

</br>

主要分析 Redis 的五大基础数据结构构造，包括 string （字符串）、list （列表）、set （集合）、hash （哈希） 和 zset （有序集合）。

<!--more-->

可以通过 ``OBJECT ENCODING keyName`` 来显示五大底层数据类型的底层数据结构。

![data-dataStructure](../../../assets/Redis基础数据结构/data-structure.jpg)

## String

String 底层数据结构有 `embstr`、`int` 和 `raw`。Redis 的字符串并非 C 语言的字符串（即以空字符’\0’结尾的字符数组），Redis 构建了一种名为 ``简单动态字符串``（simple dynamic string，SDS）的抽象类型，并作为默认字符串表示。

```c
struct sdshdr{
     //记录 buf 数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;
     //记录 buf 数组中未使用字节的数量
     int free;
     //字节数组，用于保存字符串
     char buf[];
}
```

SDS 保存字符串具体图示如下：

![SDS](../../../assets/Redis基础数据结构/SDS.png)

图片来源《Redis 设计与实现》

对于 SDS 数据类型的定义：

1. len 保存了 SDS 保存字符串的长度
2. buf[] 数组用来保存字符串的每个元素
3. free 记录了 buf 数组中未使用的字节数量

相较于 C 语言对于字符串定义，多了 len 和 free 属性，有以下好处

**1. 常数复杂度获取字符串长度**

通过 len 属性，只需要时间复杂度 O(1) 就可以获取 SDS 字符串的长度，对于 C 语言，需要遍历计算来实现，时间复杂度为 O(n)。通过 ``strlen key`` 命令可以获取 key 的字符串长度。

**2. 杜绝缓存区溢出**

C 语言中使用``strcat`` 函数进行两个字符串拼接，若没有分配足够长度的内存，就会造成缓冲区溢出。而 SDS 在字符串修改时，会先根据 len 属性检查内存是否满足需求，不满足会进行相应的空间扩展，再进行修改操作，所以不会缓冲区溢出。

**3. 减少修改字符串的内存重新分配次数**

由于 C 语言不记录字符串长度，若要修改字符串就必须要重写分配内存（先释放再申请）。若没有重新分配，字符串长度增大会造成内存缓冲区溢出，长度减少时会造成内存泄漏。

而 SDS 有 len 和 free 属性，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略：

+ 空间预分配：对字符串进行空间扩展时，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。
+ 惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然 SDS 也提供了相应的 API，当有需要时，也可以手动释放这些未使用的空间。）

**4. 二进制安全**

因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件，内容可能包括空字符串，因此 C 字符串无法正确存取；而所有 SDS 的 API 都是以处理二进制的方式来处理 buf 里的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。

**5. 兼容部分 C 字符串函数**

虽然 SDS 是二进制安全的，但一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<string.h> 中的一部分函数。

一般来说，SDS 除了保存数据库中的字符串值以外，还可以作为缓冲区（buffer）：包括 AOF 模块中的 AOF 缓冲区以及客户端状态中的输入缓冲区。

## List

C 语言内部是没有内置该数据结构的实现，Redis 自己构建了链表的实现。Redis 中列表键的底层实现之一就是链表。当一个链表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。

链表广泛应用于 Redis 的各种功能，比如链表键、发布订阅、慢查询、监视器等

```c
typedef struct listNode{
       //前置节点
       struct listNode *prev;
       //后置节点
       struct listNode *next;
       //节点的值
       void *value;  
}listNode;
```

通过多个 listNode 结构就可以组成链表，这是一个双向链表，Redis 还提供了操作链表的数据结构：

```c
typedef struct list{
     //表头节点
     listNode *head;
     //表尾节点
     listNode *tail;
     //链表所包含的节点数量
     unsigned long len;
     //节点值复制函数，用于复制链表节点所保存的值
     void (*dup) (void *ptr);
     //节点值释放函数，用于释放链表节点所保存的值
     void (*free) (void *ptr);
     //节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等
     int (*match) (void *ptr,void *key);
}list;
```

Redis 链表的特征有：

1. 双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为 O(1)。
2. 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问都是以 NULL 结束。
3. 带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。
4. 多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。

![listNode](../../../assets/Redis基础数据结构/listNode.png)

## Hash

哈希，又称为符号表、关联数组、映射（map）或字典。用于保存键值对的抽象数据结构。**Hash 中的每一个键（Key）都是唯一的**，通过 key 进行查找或修改。由于 C 语言中没有该数据结构的实现，所以 Redis 自己构建了一套。

结构定义：

```c
typedef struct dictht{
     //哈希表数组
     dictEntry **table;
     //哈希表大小
     unsigned long size;
     //哈希表大小掩码，用于计算索引值
     //总是等于 size-1
     unsigned long sizemask;
     //该哈希表已有节点的数量
     unsigned long used;
}dictht
```

哈希表是由数组 table 组成，table 中的每个元素都指向 dict.h / dictEntry 结构，dictEntry 结构定义如下：

```c
typedef struct dictEntry{
     //键
     void *key;
     //值
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     }v;
     //指向下一个哈希表节点，形成链表
     struct dictEntry *next;
}dictEntry
```

key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是 uint64_t 整数，也可以是 int64_t 整数。

注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，解决哈希冲突，有**开放地址法**和**链地址法**。Redis 采用的是链地址法，通过 next 这个指针可以将多个哈希值相同的键值对连接在一起，用来解决**哈希冲突**。

![hash](../../../assets/Redis基础数据结构/hash.png)

哈希表使用几个要点：

**1. 哈希算法**，Redis 计算哈希值和索引值方法如下：

```shell
#1、使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict->type->hashFunction(key);
#2、使用哈希表的 sizemask 属性和第一步得到的哈希值，计算索引值
index = hash & dict->ht[x].sizemask;
```

**2. 解决哈希冲突：链地址法**

通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。

**3. 扩容和缩容**

当哈希表保存的键值对太多或太少时，需要通过 rehash（重新散列）来对哈希表进行相应的扩容或收缩。具体步骤：

1. 扩容操作，会基于原哈希表创建一个大小等于 `ht[0].used*2n` 的哈希表（即每次扩展都是根据原哈希表已使用空间扩大一倍创建另一个哈希表）
2. 收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表，条件是**元素个数低于数组长度的 10%**
3. 重写利用哈希算法，计算索引值，将键值对放入新的哈希表中。
4. 所有键值对迁移完毕后，释放原哈希表的内存空间。

触发扩容条件：

1. 服务器目前没有执行 BGSAVE 命令或 BGREWRITEAOF 命令，并且负载因子大于等于 1。

2. 服务器目前正在执行 BGSAVE 命令或 BGREWRITEAOF 命令，并且负载因子大于等于 5。

> 负载因子 = 哈希表已保存节点数量 / 哈希表大小。

渐进式 rehash

扩容和收缩操作并不是一次性、集中完成的，而是分多次、渐进式完成的。

若保存在 Redis 中的键值对只有几十个，那 rehash 操作可以瞬间完成，但键值对上百万、千万甚至亿级，那一次性 rehash，势必会造成 Redis 在一段时间内停顿无法进行其他操作。

而在渐进式 rehash 期间，**字典的删除查找更新等操作可能会在两个 Hash 表上进行**，第一个没找到就去第二个哈希表上找。但新增键值对的操作一定是在新的哈希表上进行的。

## Set

集合对象 Set 是 String 类型（整数也会转化为 String 类型进行存储）的无序集合，因为无序，所以无法通过索引来操作元素；并且元素是唯一的。

### 编码

编码可以是 intset 或 hashtable

+ **intset 编码的集合对象使用整数集合作为底层实现**，集合对象包含的所有元素都被保存在整数集合中。
+ hashtable 编码的集合对象使用**字典**作为底层实现，每个字符串对象就是一个集合中的元素，而字典的值全部为 null。可以类比为 Java 中的 HashSet 由 HashMap 来实现，集合中的元素就是 HashMap 的 key，值都为 null。

### 编码转化

当集合同时满足以下两个条件时，使用 intset 编码

1. 集合对象中所有元素都是整数
2. 集合对象所有元素数量不超过 512

不能满足这两个条件就使用 hashtable 编码，第二个条件可以通过配置文件的 `set-max-intset-entries` 进行配置。

![intset](../../../assets/Redis基础数据结构/intset.png)

![hashset](../../../assets/Redis基础数据结构/hashset.png)

## ZSet

有序集合

### 编码

有序集合的编码可以是 zipList 或 skipList。

zipList 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。

并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。

![zset](../../../assets/Redis基础数据结构/zset.png)

skipList 编码的有序集合对象使用跳表作为底层数据结构

```c
typedef struct zset{
     //跳跃表
     zskiplist *zsl;
     //字典
     dict *dice;
} zset;
```

字典的键保存元素的值，字典的值则保存元素的分值；跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。

这两种数据结构会通过指针来共享相同元素的成员和分值，所以不会产生重复成员和分值，造成内存的浪费。

> 其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但这里使用两种数据结构组合起来，
> 原因是假如单独使用字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以**每次进行范围操作的时候都要进行排序**；
> 假如单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1) 的复杂度变为了 O(logN)。因此 Redis 使用了两种数据结构来共同实现有序集合。

### 编码转换

当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：

1. 保存的元素数量小于 128；
2. 保存的所有元素长度都小于 64 字节。

不能满足上面两个条件的使用 skiplist 编码。

以上两个条件也可以通过 Redis 配置文件 `zset-max-ziplist-entries` 选项和 `zset-max-ziplist-value` 进行修改。

## 参考资料

《Redis 设计与实现》