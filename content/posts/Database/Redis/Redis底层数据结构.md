---
title: Redis 底层数据结构
description: 主要分析 Redis 底层的数据结构模型
toc: true
authors: 
    - WayneShen
tags: 
    - Redis
categories: 
    - DataBase
series: []
date: '2021-07-31T10:00:+08:00'
lastmod: '2021-07-31T10:00:20+08:00'
draft: false
---

</br>

主要分析 Redis 底层的数据结构模型

<!--more-->

## Redis 底层数据基础结构

Redis 底层就是全局哈希表，为了用 O(1) 的时间复杂度找到键值对。只需要计算键的哈希值，就可以知道对应的哈希桶位置，然后就可以找到访问相应的 entry 元素。

所以查找的过程主要依赖于哈希计算，与数据量没有直接的关系。

若写入大量数据后，发现操作变慢，潜在的原因**可能就是哈希表的冲突问题和 rehash 可能带来的操作的阻塞**。

### 哈希表操作变慢

哈希冲突指的是，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。这是不可避免的。

Redis 解决 hash 冲突的方式是，**链式哈希**，也就是说，**同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。该链表也叫做哈希冲突链。

哈希表里写入的数据越来越多，导致冲突越来越多，冲突链也可能过长。而冲突链只能通过指针逐一查找，导致元素查找耗时较长。

### rehash

由于 Hash 冲突的存在，Redis 会对哈希表做 rehash 操作，rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。

一开始，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

至此，就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。

过程看似简单，但是第二步涉及大量的数据拷贝，若一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。

为了避免这个问题，Redis 采用了**渐进式 rehash**。

简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。

这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

## 数据结构及效率

### String 类型

对于 String 类型，找到哈希桶就能直接增删改查了，所以哈希表的 O(1) 操作复杂度也就是其复杂度了。

内部结构类似 Java 中的 ArrayList（**字节数组的形式**，预分配冗余空间）。并且规定长度不得超过 512M。

**扩容机制**

字符串在长度小于 1M 之前，扩容空间采用加倍策略，也就是保留 100% 的冗余空间。当长度超过 1M 之后，为了避免加倍后的冗余空间过大而导致浪费，每次扩容只会多分配 1M 大小的冗余空间。

### 集合类型

对于集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。

集合的操作效率与**底层数据结构**和**操作复杂度**有关。例如：

+ 使用哈希表实现的集合，要比使用链表实现的集合访问效率更高。
+ 操作效率和这些操作本身的执行特点有关，比如读写一个元素的操作要比读写所有元素的效率高。

集合类型的底层数据结构主要有 5 种：**整数数组、双向链表、哈希表、压缩列表和跳表**。

#### 整数数组和双向链表

整数数组和双向链表的操作特征都是**顺序读写**。

也就是**通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是 O(n)**，操作效率比较低。

#### 压缩列表-ZipList

ZipList 实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。

和数组不同的是，压缩列表在表头有三个字段 zlbytes（列表长度）、zltail_offset（列表尾的偏移量）和 zllen（列表中的 entry 个数）；压缩列表在表尾还有一个 zlend，表示列表结束。

**ZipList 是 redis 为了节省内存而开发的**，由一系列**特殊编码的连续内存块组成的顺序型数据结构**，一个 ZipList 可以包含任意多个节点（entry），每个节点可以保存一个字节数组或整数值。

**压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。**

在压缩列表中，若要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N)。

ziplist 结构的缺点是，每次插入或删除一个元素时，都需要进行频繁的调用 `realloc()` 函数进行内存的扩展或减小，然后进行数据”搬移”，甚至可能引发连锁更新，造成严重效率的损失。

![ziplist](../../../assets/Redis底层数据结构/ziplist.jpg)

```C++
struct ziplist {    
    int32 zlbytes; // 整个压缩列表占用字节数，即列表长度   
    int32 zltail_offset; // 最后一个元素距离起始位置的偏移量，用于快速定位到最后一个节点，就可以支持双向遍历
    int16 zllength; // 元素个数
    T[] entries; // 元素内容列表，挨个紧凑存储
    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF 
}
```

若 ZipList 占用内存过大，重新分配内存和拷贝内存就会有很大的消耗。所以 ZipList 不适合存储大型字符串，存储的元素也不宜过多。

压缩列各个组成部分的详细说明

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4 字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或计算 zlend 的位置时使用 |
| zltail  | uint32_t | 4 字节 | 记录压缩列表表尾节点距离压缩列表起始地址的字节数：<br>通过该偏移量，程序无需遍历整个压缩列表就可确定表尾节点的地址 |
| zllen   | uint16_t | 2 字节 | 记录了压缩列表包含的节点数量。<br>当这个属性值小于 UINT16_MAX（65535）时，该属性的值就是压缩列表包含节点的数量；<br>当这个值等于 UINTI6_MAX 时，节点的真实数量需遍历整个压缩列表才能计箅得出 |
| entryX  | 列表节点 | 不定  | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1 字节 | 特殊值 0xFF（十进制 255)，用于标记压缩列表的末端               |

![part_ziplist](../../../assets/Redis底层数据结构/part_ziplist.png)

1. previous_entry_length：记录压缩列表前一个节点的长度。该长度可能是 1 个字节或 5 个字节，若上一个节点的长度小于 254，则该节点只需一个字节就可以表示，若前一个节点的长度大于等于 254，则 previous length 的第一个字节为 254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。
2. encoding：保存的是节点的 content 的内容类型以及长度，encoding 类型有两种，字节数组、整数。encoding 区域长度为 1 字节、2 字节或者 5 字节长。
3. content：用于保存节点内容，节点内容类型和长度由 encoding 决定

ziplist 的优点是内存紧凑，访问效率高，缺点是更新效率低，并且数据量较大时，可能导致大量的内存复制

总结 ziplist 的特点为：

+ 结构紧凑：一整块连续内存，没有多余的内存碎片，内存紧凑，访问效率高，但缺点是更新效率低，数据量较大时，可能导致大量内存复制，平均时间复杂度为 O(N)。
+ 逆向遍历：从表尾开始向表头进行遍历（注意了！，但是插入还是在表头）
+ 连锁更新：对前一条数据的更新，可能导致后一条数据的 prev_entry_length 与 encoding 所需长度变化，产生连锁反应，更新操作最坏时间为 O(N2)

#### 快速列表-QuickList

QuickList 是 ZipList 和 LinkedList 的混合体，将 LinkedList 按段切分，每段使用 ZipList 来紧凑存储，多个 ZipList 之间使用双向指针串接起来，属于双向链表。用在数据量多的时候。

由于是双向链表，所以具有双向链表的优点，插入或删除操作非常方便，虽然复杂度为 O(n)，但不需要内存的复制，提高了效率，而且访问两端元素复杂度为 O(1)。

从微观上，是一段段的 entry 节点，每个 entry 节点内存连续且顺序存储，可以通过二分查找以 O(logn) 的复杂度进行定位。

![quicklist](../../../assets/Redis底层数据结构/quicklist.png)

```C++
struct ziplist_compressed {    
    int32 size;    
    byte[] compressed_data;
}
struct quicklistNode {   
    quicklistNode* prev;   
    quicklistNode* next;   
    ziplist* zl; // 指向压缩列表   
    int32 size; // ziplist 的字节总数   
    int16 count; // ziplist 中的元素数量   
    int2 encoding; // 存储形式 2bit，原生字节数组还是 LZF 压缩存储    
    //... 
} 
struct quicklist {  
    quicklistNode* head;  
    quicklistNode* tail;  
    long count; // 元素总数  
    int nodes; // ziplist 节点的个数  
    int compressDepth; // LZF 算法压缩深度  
    //... 
}
```

为了进一步节省空间 ZipList 可以用 LZF 算法进行压缩，压缩深度由 list-compress-depth 控制。

#### 跳表-SkipList

跳表用于解决有序链表只能逐一查找元素，导致操作非常缓慢的问题。

具体来说，跳表在链表的基础上，**增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位**。

当数据量很大时，跳表的查找复杂度就是 O(logN)。Sorted Set 底层就是跳表。

跳表的结构：

1. 由多层链表组成，每层都是一个有序的链表，排序顺序由高层到底层，都至少包含两个链表节点，分别是前者的 head 节点和后面的 nil 节点
2. 最底层链表包含了所有的元素
3. 若一个元素出现在某一层链表中，那么在该层之下的链表也都会出现
4. 链表中的每个节点都包含两个指针，一个指向同层下一个节点，另一个指向下一层的同值的链表节点。

跳表操作：

+ 查询：从高层的链表节点开始，若比当前节点要大，比当前层得下个节点要小，则往下找，与下一层的下一个节点比较，以此类推，直至找到。
+ 插入：首先确定插入的层数，随机，类似抛硬币，正面则累加，直至遇到反面，最后记录正面次数作为插入层数，当确定插入层数 k 后，需要将新元素插入到从底层到 k 层。
+ 删除：在各层中找到包含指定数的节点，再将节点从链表中删除即可，若删除后，只剩头尾两个节点，则删除该层。

![img](../../../assets/Redis底层数据结构/redis-dataStructure.jpg)

### 不同操作的复杂度

集合类型的操作类型很多，有读写单个集合元素，也有操作多个元素，还有对整个集合进行遍历操作的。

这些操作下，复杂度也各不相同。而复杂度的高低又是选择集合类型的重要依据。在使用过程中，需要提前规避高复杂度操作。

- 单元素操作是基础；
- 范围操作非常耗时；
- 统计操作通常高效；
- 例外情况只有几个。

**1. 单元素操作，是指每一种集合类型对单个数据实现的增删改查操作**。

例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。

需要注意的是，集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。

**2. 范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据**。

比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。**这类操作的复杂度一般是 O(N)，比较耗时，应该尽量避免**。建议尽量**用其他命令来替代**，例如可以用 SCAN 来代替，避免在 Redis 内部产生费时的全集合遍历操作。

Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。

**3. 统计操作，是指集合类型对集合中所有元素个数的记录**。

例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。

**4. 例外情况，是指某些数据结构的特殊记录**。

例如**压缩列表和双向链表都会记录表头和表尾的偏移量**。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。

### keys 命令

keys 命令的作用是列出 Redis 所有的 key，该命令的时间复杂度为 O(N)，N 随着 Redis 中 key 的数量增加而增加，因此 Redis 有大量的 key，keys 命令会执行很长时间。

而由于 Redis 是单 worker 线程，某个命令耗费过长时间，则会导致后面的的所有请求无法得到响应，因此，千万不要在生产服务器上使用 keys 命令。

```shell
# key 命令，时间复杂度为 O(n)
keys pattern #pattern 可为一个包含匹配模式的字符串，可以包含*,+,?,[a-z] 等模式。
```

## 参考资料

《Redis 设计与实现》