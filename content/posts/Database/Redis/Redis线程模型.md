---
title: Redis 线程模型
description: 主要分析 Redis 的线程模型吗，以及 Redis 为何快
toc: true
authors: 
    - WayneShen
tags: 
    - Redis
categories: 
    - DataBase
series: []
date: '2021-07-31T13:30:+08:00'
lastmod: '2021-07-31T13:30:20+08:00'
draft: false
---

</br>

主要分析 Redis 的线程模型吗，以及 Redis 为何快

<!--more-->

文件事件处理器，是一个网络事件处理器，是单线程的，**采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器来处理这个事件。**

## 高性能 IO 模型

通常说 Redis 是单线程，主要是指 **Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程**。

但 Redis 的其他功能，比如**持久化、异步删除、集群数据同步等，其实是由额外的线程执行的**。

所以，严格来说，Redis 并不是单线程。其高性能主要依赖于单线程设计机制以及多路复用机制。操作时也需要避免会导致 Redis 单线程阻塞的操作，例如执行复杂度高的命令。

## Redis 为什么用单线程？

### 多线程的开销

对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。

但通常情况下，在采用多线程后，如果没有良好的系统设计，实际得到的结果可能是，刚开始增加线程数时，系统吞吐率会增加，但再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。

一个关键的瓶颈在于，**系统中通常会存在被多线程同时访问的共享资源**，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，即**共享资源的并发访问的控制问题**，而这个额外的机制，就会带来额外的开销。

若没有精细的设计，比如简单地使用了一个粗粒度互斥锁，结果往往不理想：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。

而且多线程保护共享资源并发访问引入的同步原语，通常会降低代码的易调试性和可维护性。

为了避免以上问题，Redis 直接采用了单线程模型。

### 单线程快的原因

通常情况下，单线程的处理能力要比多线程差很多，但 Redis 却能使用单线程模型达到每秒数十万级别的处理能力。

+ 一方面，Redis 的**大部分操作在内存上完成**，加上它采用了高效的数据结构，例如哈希表和跳表，这是高性能的一个重要原因。
+ 另一方面，Redis 采用了**多路复用机制**，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

通常情况说的 Redis 单线程是指它**对网络 IO 和数据读写的操作采用了一个线程**。而采用单线程的一个核心原因是**避免多线程开发的并发控制问题**。



Redis 6.x之前，操作串行化，符合原子性。优点是，串行化无需锁，降低了切换消耗，比其他串行相对快。缺点是，无法用上多核CPU优势。



### 多路复用机制

#### 基本 IO 模型和阻塞点

以 Get 请求为例，同步阻塞 IO 模型为了处理一个 Get 请求，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。

若采用该网络 IO，操作中的 `accept()` 和 `recv()` 是潜在的阻塞点。

当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 `accept()` 函数里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 `recv()` 从一个客户端读取数据时，若数据一直没有到达，Redis 也会一直阻塞在 `recv()`。

这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是，socket 网络模型本身支持非阻塞模式。

#### 非阻塞模型

Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上。

在 socket 模型中，不同操作调用后会返回不同的套接字类型。`socket()` 方法会返回主动套接字，然后调用 `listen()` 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 `accept()` 方法接收到达的客户端连接，并返回已连接套接字。

![socket_function](../../../assets/Redis线程模型/socket_function.jpg)

针对监听套接字，可以设置非阻塞模式：当 Redis 调用 `accept()` 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但需要注意的是，调用 `accept()` 时，已经存在监听套接字了。

虽然 Redis 线程可以不用继续等待，但总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

类似的，也可以针对已连接套接字设置非阻塞模式：Redis 调用 `recv()` 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis。

这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。此时，就需要用到 Linux 中的 IO 多路复用机制了。

#### 基于多路复用的高性能 I/O 模型

Linux 中的 **IO 多路复用机制是指一个线程处理多个 IO 流**，就是经常听到的 select/epoll 机制。

![multiplex](../../../assets/Redis线程模型/multiplex.png)

简单来说，在 Redis 只运行单线程的情况下，**该机制允许内核中，同时存在多个监听套接字和已连接套接字**。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

下图就是基于多路复用的 Redis IO 模型。图中的多个 FD（文件描述符） 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。

此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。

![epoll](../../../assets/Redis线程模型/epoll.jpg)

为了在请求到达时能通知到 Redis 线程，select/epoll 提供了**基于事件的回调机制**，即**针对不同事件的发生，调用相应的处理函数**。回调机制就是，**select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件**。

这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。

为了方便理解，以连接请求和读数据请求为例，具体解释一下。

这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。

![single_thread](../../../assets/Redis线程模型/single_thread.png)

需要注意的是，即使应用场景中部署了不同的操作系统，多路复用机制也是适用的。因为这个机制的实现有很多种，既有基于 Linux 系统下的 select 和 epoll 实现，也有基于 FreeBSD 的 kqueue 实现，以及基于 Solaris 的 evport 实现，这样就可以根据 Redis 实际运行的操作系统，选择相应的多路复用实现。

### 6.0 后的多线程模型

2020 年 5 月，Redis 6.0 的稳定版发布了，Redis  6.0 中提出了多线程模型。

Redis 6.x后增加io threads，操作读写IO和数据处理多线程处理。并发做的不是一类事，是一种并行。

![multi_thread](../../../assets/Redis线程模型/multi_thread.png)

图中 C1 与 C2 两者的计算可能出现乱序，但其实本身 C1 和 C2 的并发请求也是无序的，如果想保证 redis 执行的顺序，可以通过客户端请求时的请求负载来控制，比如相同的业务的 uri 打到一台机器上。

## 参考资料

《Redis 设计与实现》

《Redis 核心技术与实战》