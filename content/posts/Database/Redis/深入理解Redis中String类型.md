---
title: 深入理解Redis中的String类型 
description: 深入分析 Redis 中的 String 类型底层结构编码模式，以及其使用场景。
toc: true
authors: 
    - WayneShen
tags: 
    - Redis
categories: 
    - DataBase
series: []
date: '2021-07-31T20:00:+08:00'
lastmod: '2021-07-31T20:00:20+08:00'
draft: false
---

</br>

深入分析 Redis 中的 String 类型底层结构编码模式，以及其使用场景。

<!--more-->

String 类型虽可以应用于很多场景，但他明显的短板就是**保存数据时所消耗的内存空间较多**。

集合类型中有数据结构比较节省内存空间的，采用二级编码，相比 String 类型可以明显减少内存空间消耗。

## String 底层结构

除了记录实际数据，String 类型还需要额外的内存空间记录元数据（数据长度、空间使用等信息），若实际保存的数据较小时，元数据占用空间的开销就相对较大了。

当保存 64 位有符号整数时，String 类型会保存为一个 8 字节的 Long 类型整数（8 字节的 Long 类型最大可以表示 2 的 64 次方的数值），也被叫做 **int 编码**方式。

当保存数据中**包含字符时**，String 类型会使用**简单动态字符串（Simple Dyamic String，SDS）** 结构来保存。

- **buf**：字节数组，保存实际数据。Redis 自动在字节数组最后加一个“\0”表示数组的结束，额外产生 1 个字节的开销。
- **len**：占 4 个字节，表示 buf 的已用长度。
- **alloc**：也占个 4 字节，表示 buf 的实际分配长度，一般大于等于 len。

在 SDS 中，buf 保存实际数据，而 len 和 alloc 就是 SDS 结构体的额外开销。对于 String 类型，除了 SDS 的额外开销，还有一个来自 RedisObject 结构体的开销。

Redis 的数据类型有很多，而且不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以 Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。

一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在，例如指向 String 类型的 SDS 结构所在的内存地址

![redisObject](../../../assets/深入理解Redis中的String类型/redisObject.jpg)

为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计：

+ 一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。
+ 另一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 **embstr 编码模式**。

当然，当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起，而是给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 **raw 编码模式**。

理解 int、embstr 和 raw 这三种编码模式，如下所示：

![string_encoding](../../../assets/深入理解Redis中的String类型/string_encoding.jpg)

加上 RedisObject 所包含的额外元数据开销，就可以计算 String 类型的内存使用量了。

一个 10 位数的 key 和 value 是 Long 类型整数，可以直接用 int 编码的 RedisObject 保存，每个 int 编码的 RedisObject 元数据部分占 8 字节，指针部分被直接赋值为 8 字节的整数了，加起来是 32 字节。

Redis 使用全局哈希表保存所有键值对，哈希表的每一项是 dictEntry 的结构体，用来指向一个键值对，dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节

![dictEntry](../../../assets/深入理解Redis中的String类型/dictEntry.jpg)

除了这三个指针的 24 字节，Redis 还使用的内存分配库 jemalloc。

jemalloc 在分配内存时，会根据申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。所以在刚刚的场景中，dictEntry 结构就占用了 32 字节。

上述案例中，明明有效信息只有 16 字节，使用 String 类型保存时，却需要 64 字节的内存空间，有 48 字节都没有用于保存实际的数据。此时相对的额外内存开销较大。

### 重新选择数据结构

Redis 的一种底层数据结构**压缩列表**（ziplist），是一种非常节省内存的结构。

ziplist 表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束。

![ziplist](../../../assets/深入理解Redis中的String类型/ziplist.jpg)

压缩列表之所以能节省内存，在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。

- **prev_len**，表示前一个 entry 的长度。prev_len 有两种取值情况：1 或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。
- **len**：表示自身长度，4 字节；
- **encoding**：表示编码方式，1 字节；
- **content**：保存实际数据。

这些 entry 会挨个放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。

通过上述案例分析压缩列表是如何节省内存空间的：

每个 entry 保存一个 value（8 字节），此时，每个 entry 的 prev_len 只需要 1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节。这样一来，每个值占用的内存大小是 14 字节（1+4+1+8），实际分配 16 字节。

Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。

该方案听起来不错，但仍存在一个问题：在用集合类型保存键值对时，一个键对应了一个集合的数据，但是在上述场景中，在一个键对应一个值（也就是单值键值对）的情况下，该怎么用集合类型来保存这种单值键值对呢？

## 用集合类型保存单值的键值对

在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，就可以把单值数据保存到 Hash 集合中了。

以 key=1101000060 和 value=3302000080 为例，可以把 key 的前 7 位（1101000）作为 Hash 类型的键，把 key 的最后 3 位（060）和 value 分别作为 Hash 类型值中的 key 和 value。

按照这种设计方法，在 Redis 中插入了一组 key,value 的记录，并且用 info 命令查看了内存开销，可以发现，增加一条记录后，内存占用只增加了 16 字节，如下所示：

```
127.0.0.1:6379> info memory
# Memory
used_memory:1039120
127.0.0.1:6379> hset 1101000 060 3302000080
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1039136
```

在使用 String 类型时，每个记录需要消耗 64 字节，此时却只用了 16 字节，所使用的内存空间是原来的 1/4，满足节省内存空间的需求。

把键的前 7 位作为 Hash 类型的键，把最后 3 位作为 Hash 类型值中的 key，因为**二级编码方法中采用的 ID 长度是有讲究的**。

Redis Hash 类型的两种底层实现结构，分别是压缩列表和哈希表。Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。

这两个阈值分别对应以下两个配置项：

- `hash-max-ziplist-entries`：表示用压缩列表保存时哈希集合中的最大元素个数。
- `hash-max-ziplist-value`：表示用压缩列表保存时哈希集合中单个元素的最大长度。

若往 Hash 集合中写入的元素个数超过了 `hash-max-ziplist-entries`，或写入的单个元素大小超过了 `hash-max-ziplist-value`，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。

一旦转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。

**为了能充分使用压缩列表的精简内存布局，一般要控制保存在 Hash 集合中的元素个数**。所以，在刚才的二级编码中，只用图片 ID 最后 3 位作为 Hash 集合的 key，也就保证了 Hash 集合的元素个数不超过 1000，同时，我们把 hash-max-ziplist-entries 设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。

## 推荐

如果想知道键值对采用不同类型保存时的内存开销，可以在 [这个网址](http://www.redis.cn/redis_memory/) 里输入键值对长度和使用的数据类型，这样就能知道实际消耗的内存大小了

## 参考资料

《Redis 设计与实现》

《Redis 核心技术与实战》