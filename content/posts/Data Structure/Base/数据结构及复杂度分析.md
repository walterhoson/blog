---
title: 数据结构及复杂度分析
description: 从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。其中重要的概念就是复杂度分析。
toc: true
authors: 
    - WayneShen
tags: 
    - Data Structure
    - Notes
categories: 
    - Data Structure
series: []
date: '2021-05-31T22:21:+08:00'
lastmod: '2021-05-31T22:21:29+08:00'
featuredImage: ''
draft: false
---

从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。其中重要的概念就是复杂度分析。



<!--more-->

## 数据结构与算法

从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。

数据结构是为算法服务的，算法要作用在特定的数据结构之上。数据结构是静态的，它只是组织数据的一种方式。

如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。

![image-20201027191145978](../../../assets/数据结构及复杂度分析/image-20201027191145978.png)

### 基础

10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；

10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。



## 复杂度分析

### 事后统计法

把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。如此评估叫做 **事后统计法**。

有几个坏处

+ 测试结果非常依赖测试环境
+ 测试结果受数据规模的影响很大

### 大O复杂度表示法

#### 概念

T(n) = O( &fnof;(n) )

T(n)表示代码执行的时间；n 表示数据规模的大小；&fnof;(n) 表示每行代码执行的次数总和（是一个公式）。

公式中的 O，表示代码的执行时间 T(n) 与 &fnof;(n) 表达式成正比。

公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了。

大 O 时间复杂度并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，也叫作**渐进时间复杂度**（asymptotic time complexity），简称时间复杂度。

#### 时间复杂度分析

只关注循环执行次数最多的一段代码

加法法则：总复杂度等于量级最大的那段代码的复杂度

乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

##### 复杂度量级

常数阶 O(1) < 对数阶 O(logn) < 线性阶 O(n) < 线性对数阶 O(nlogn) < 平方阶 O(n2) < 立方阶 O(n3)、、、k次方阶 O(nk) < 指数阶 O(2n) < 阶乘阶 O(n!)

**指数阶和阶乘阶属于非多项式量级**。非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确
定多项式）问题。

**O(1)**

只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

**O(logn)、O(nlogn)**

$$
log_3 n  = log_23 * log_2n
$$

在采用大 O 标记复杂度时，可以忽略系数（常数），即 O(Cf(n)) = O(f(n))。所以 O(log2n) 就等于 O(log3n)。所以忽略底数统一表示为 O(logn)。

若一段代码的时间复杂度是 O(logn)，循环执行 n 遍，时间复杂度就是 O(nlogn)。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

**O(m+n)、O(m*n)**

若一段代码中有两个时间复杂度，无法事先评估谁的量级大，所以不能使用加法法则，省略其中一个。所以由两个数据的规模来决定。

##### 复杂度对比图

![img](../../../assets/数据结构及复杂度分析/1024px-Comparison_computational_complexity.svg.png)

#### 空间复杂度分析

全称就是**渐进空间复杂度**（asymptotic space complexity），表示**算法的存储空间与数据规模之间的增长关系**。

省略已知的常数阶，常见的空间复杂度就是 O(1)、O(n)、O(n )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平
时都用不到。

### 最好、最坏、平均、均摊时间复杂度

最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）

#### 最好情况时间复杂度

best case time complexity。

在最理想的情况下，执行这段代码的时间复杂度。比如要找的刚好是第一个。

#### 最坏情况时间复杂度

worst case time complexity。

在最糟糕的情况下，执行这段代码的时间复杂度。比如没有找到导致遍历全部。

#### 平均情况时间复杂度

举例：查找的变量 x，假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。但这个结果并没有加入所有情况发生的概率考虑进去。

所以结果应该为：（1+2+3+...+n）* 1/2n + n/2 = (3n+1)/4

这个值就是概率论中的**加权平均值**，也叫作**期望值**，所以平均时间复杂度的全称应该叫**加权平均时间复杂度**或**期望时间复杂度**。所以结果 (3n+1)/4，去掉系数和常数，为O(n)

#### 均摊时间复杂度

对应的分析方法叫**摊还分析**（或叫平摊分析），属于一种特殊的平均时间复杂度。

举例，有一次O(n)，后面紧跟n-1 次 O(1) ，此时均摊下来就是O(1)。对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。



## 主定理

在算法分析中，**支配理论**（master theorem）提供了用渐近符号（大O符号）表示许多由分治法得到的递推关系式的方法。被描述为解决这种递推的“天下无敌法”(master method)。此方法经由经典算法教科书《算法导论》 (introduction to algorithm) 推广而为人熟知。

不过，并非所有递推关系式都可应用支配理论。

### 常用算法中的应用

![img](../../../assets/数据结构及复杂度分析/image-20210316220553152.png)



## 参考资料

《数据结构与算法之美》
