---
title: 基础数据结构-堆
description: 堆（Heap）属于一种特殊的树。
toc: true
authors: 
    - WayneShen
tags: 
    - Data Structure
    - Notes
categories: 
    - Data Structure
series: [Data Structure]
date: '2021-06-02T00:30:08+08:00'
lastmod: '2021-06-02T00:30:08+08:00'
featuredImage: ''
draft: false
---

</br>

堆（Heap）属于一种特殊的树。

<!--more-->

## 概念

+ 堆是一个完全二叉树（除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列）；
+ 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

对于每个节点的值都大于等于子树中每个节点值的堆，叫做**大顶堆**；相反，对于每个节点的值都小于等于子树中每个节点值的堆，叫做**小顶堆**。

## 实现

完全二叉树比较适合用数组来存储，非常节省存储空间。不需要存储左右字节点的指针，单纯地通过数组的下标就可以找到一个节点的左右字节点和父节点。

数组中下标为 i 的节点的左子节点，就是下标为 i * 2 的节点，右子节点就是下标为 i * 2 + 1 的节点，父节点就是下标为 i / 2 的节点。

### 插入元素

插入元素后，需要继续满足堆的两个特性，就需要进行调整，也就是**堆化（heapify）**。

堆化分两种，从下往上和从上往下。

从下往上堆化，就是顺着节点所在的路径，向上或向下，对比然后交换。也就是节点追加到末尾，然后与父节点对比，不满足则交换，在依次往上。

```java
public class Heap {
  private int[] a; // 数组，从下标 1 开始存储数据
  private int n;  // 堆可以存储的最大数据个数
  private int count; // 堆中已经存储的数据个数
  public Heap(int capicity) {
    a = new int[capicity + 1];
    n = capicity;
    count = 0;
  }
  public void insert(int data) {
    if (count >= n) return; // 堆满了
    ++count;
    a[count] = data;
    int i = count;
    while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
      swap(a, i, i/2); // swap() 函数作用为 交换下标为 i 和 i/2 的两个元素
      i = i/2;
    }
  } 
}
```

### 删除元素

堆顶元素为最大值或最小值。假如是个大顶堆：

```java
public void removeMax() {
  if (count == 0) return-1; //堆中没有数据
  a[1] = a[count];
  --count;
  heapify(a, count, 1);
}
private void heapify(int[] a, int n, int i) {//自上往下堆化
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos ==i) break;
    swap (a, i, maxPos);
    i = maxPos;
  }
}
```

## 堆排序

堆排序是一种原地的，时间复杂度为 O(nlogn) 的排序算法。 比快排更加稳定，但性能没有快排好。

### 建堆

从前往后并且每个数组数据插入堆中时，都是从下往上堆化。或从后往前处理数组数据，并且每个数据都是从上往下堆化。以下实现为从后往前处理：

```java
private static void buildHeap(int [] a, int n) {
  for (int i = n/2; i>= 1;--i) {
    heapify(a, n, i);
  }
  private static void heapify(int[] a, int n, int i) {
    while (true) {
      int maxPos = i;
      if (i*2 <=n && a[i] < a[i*21) maxPos = i*2;
      if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
      if (maxPos == i) break;
      swap(a, i, maxPos);
      i = maxPos;
	}
}
```

因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。

每个非叶子节点的高度求和为：S1 = 1 * h + 2<sup>1</sup>* (h-1) + 2<sup>2</sup>* (h-2) +...+ 2<sup>k</sup>(h-k) +...+  2<sup>h-1</sup> * 1

通过公式两端乘 2 得到 S2，用 S2-S1，最终计算出 h = log<sub>2</sub>n，带入公式，得到 S = O(n)，**所以建堆的时间复杂度为 O(n)**。

### 排序

建堆结束后，若是大顶堆的情况下，数组第一个元素就是堆顶，也就是最大元素。只需要把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。然后堆化，将剩下的 n-1 个元素重新构建成堆。然后再取堆顶元素，放到下标为 n-1 的位置。以此重复这个过程，直到最后堆中只剩 下标为 1 的元素，就完成了排序。

![sort](../../../assets/基础数据结构-堆/sort.png)

```java
public static void sort(int[] a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    swap(a, 1, k);
    --k;
    heapify(a, k, 1);
  }
}
```

以上代码，默认堆中数据从数组下标 1 开始存储 h

排序过程的时间复杂度是 O(nlogn)，加上建堆的时间复杂度 O(n)，所以堆排序整体的时间复杂度为 O(nlogn)。堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

### 快排性能比堆排序好

1. 堆排序数据访问方式没有快排友好，堆排序在排序时数据跳着访问，对 CPU 不友好。而快排是局部顺序访问的。
2. 快排是基于比较和交换的，交换次数不会比逆序度多，而堆排序首先要先建堆，会打乱数据原有的相对先后顺序，导致原有有序度降低。已经有序的数据建堆后，数据反而变得更加无序了

## 应用

### 优先级队列

优先级队列定义：数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的最先出队。应用场景有：赫夫曼编码、图的最短路径、最小生成树算法等等。实现有 Java 中的 PriorityQueue

而堆可以看做是一个优先级队列，优先级队列插入元素，相当于堆插入一个元素；优先级队列取出优先级最高的元素，相当于去除堆顶元素。

#### 具体示例

**1. 合并有序小文件**

假如有 100 个小文件，每个文件大小 100MB，每个文件中存储的都是有序的字符串，此时希望将这些小文件合并成一个有序的大文件。

实现方案为，将小文件中取出字符串放入到小顶堆，堆顶的元素，就是优先级队列对手的元素，即最小的字符串，将其放入大文件中，并从堆中删除，在从小文件中取出下一个字符串放入堆中，循环这个过程就可以将 100 个小文件中的数据一次放入到大文件中了。删除堆顶数据和往堆中插入数据是时间复杂度都为 O(logn)，n 表示堆中的数据个数，即 100。

**2. 高性能定时器**

假设有一个定时器，维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒） ，就扫描一遍任务，看是否有任务到达设定的执行时间，如果到了，则拿出来执行。

每过 1 秒扫描一遍任务列表比较低效。此时可以按照任务执行时间将这些任务存储在优先级队列中，队首（小顶堆堆顶），就是最先要执行的任务。无需每秒就轮训，只需要到堆顶的时间

### 利用堆求 Top K

Top K 问题分为两类，一类是针对静态数据集合，另一类针对动态数据集合。

#### 静态数据

查找前 K 大的数据的话，维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较，如果比堆顶元素大，则把堆顶元素删除，并将这个这个元素插入堆中；如果比堆顶元素小，则不做处理。遍历玩数组堆中的数据就是前 K 大数据了。

遍历数组时间复杂度为 O(n)，一次堆化需要 O(logk)，最坏情况下，n 个元素都要入堆一次，时间复杂度为 O(nlogk)。

#### 动态数据

针对动态数据求实时 TopK，也只是需要一直维护一个 K 大小的小堆顶，一边遍历或者实时数据与小顶堆做比较，与静态数据一致。

### 利用堆求中位数

维护两个堆，一个大顶堆，一个小顶堆，大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。

堆化时间复杂度为 O(logn)，而取出中位数的时间复杂度为 O(1)

## 参考资料

《数据结构与算法之美》