---
title: 位图
description: 主要分析位图（BitMap）的原理及使用场景。
toc: true
authors: 
    - WayneShen
tags: 
    - Data Structure
    - Notes
categories: 
    - Data Structure
series: 
date: '2021-06-05T19:00:08+08:00'
lastmod: '2021-06-05T19:00:08+08:00'
featuredImage: ''
draft: false
---

</br>

主要分析位图（BitMap）的原理及使用场景。

<!--more-->

## 位图（BitMap）

若有 1 千万个整数，整数的范围是 1 到 1 亿，使用一个特殊的散列表，也就是位图，先申请一个大小为 1 亿、数据类型为布尔类型的数组，将 1 千万个整数作为数组下标，对应数组的值设置为 true。当查询某个整数 K 是否在这个 1 千万个整数中的时候，只需要将对应的数组值 array[K] 取出来，看是否等于 true，是则表示这 1 千万整数中包含这个整数 K，false 表示不存在。

使用语言中的布尔类型，大小占用 1 个字节，并不能节省内存空间，而实际上 true 和 false 两个值，只需要使用一个二进制位（bit）就行，使用位运算。

```java
public class BitMap {
  private final char[] bytes;
  private final int nbits;

  public BitMap(int nbits) {
      this.nbits = nbits;
      this.bytes = new char[nbits / 8 + 1];
  }

  public void set(int k) {
      if (k > nbits) return;
      int byteIndex = k / 8;
      int bitIndex = k % 8;
      bytes[byteIndex] |= (1 << bitIndex);
  }

  public boolean get(int k) {
      if (k > nbits) return false;
      int byteIndex = k / 8;
      int bitIndex = k % 8;
      return (bytes[byteIndex] & (1 << bitIndex)) != 0;
  }
}
```

 使用散列表存储这个 1 千万数据，数据是 32 位整型数（4 个字节），至少需要 40M 的内存空间，若使用位图，数字范围若在 1 到 1 亿，只需要 1 亿个二进制位，也就是 12M 左右的存储空间。若数字范围在 1 到 10 亿，位图的大小就是 10 亿个二进制位，也就是 120M，消耗的空间增加了。此时就需要布隆过滤器了。

## 布隆过滤器

Bloom Filter 基于位图的优化。

基于以上的例子，若数据范围是 1 到 10 亿，布隆过滤器的做法是仍然使用一个 1 亿个二进制大小的位图；通过哈希函数，对数字进行处理，让其落在这 1 到 1 亿范围内。比如把哈希函数设计成 `f(x) = x % n`。

其中，x 表示数字，n 表示位图的大小 (1 亿），对数字跟位图的大小进行取模求余。但此时一个哈希函数会存在冲突，1 亿零 1 和 1 这两个数字，哈希函数的结果都为 1，无法区分。

为了降低冲突概率，可以设计一个复杂、随机的哈希函数。除此之外，既然一个哈希函数可能存在冲突，那可以**用多个哈希函数一块定位一个数据**。

使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值，分别记作 Xi，X2，X3，...X<sub>k</sub>。把这 K 个数字作为位图中的下标，将对应的 BitMap[X<sub>1</sub>]，BitMap[X<sub>2</sub>]，BitMap[X<sub>3</sub>]，...，BitMap[X<sub>k</sub>] 都设置成 true，也就是说，用 K 个二进制位，来表示一个数字的存在。

当要查询某个数字是否存在时，用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 Y<sub>1</sub>, Y<sub>2</sub>, Y<sub>3</sub>, .. Y<sub>k</sub>。看这 K 个哈希值，对应位图中的数值是否都为 true，若都是 true，则说明这个数字存在，若有其中任意一个不为 true，则说明这个数字不存在。

对于两个不同的数字来说，经过一个哈希函数处理后，可能会产生相同的哈希值。但是**经过 K 个哈希函数处理之后，K 个哈希值都相同的概率就非常低**。尽管概率降低了，但这种处理方式又带来了新的问题，就是容易误判。比如：

![Misjudgment](../../../assets/位图/Misjudgment.png)

布隆过滤器的误判有一个特点，它**只会对存在的情况有误判**。**若某个数字经过布隆过滤器判断不存在，说明这个数字真的不存在**，不会发生误判，**若某个数字经过布隆过滤器判断存在，此时才会有可能误判，有可能并不存在**。不过，只要**调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低**。

尽管布隆过滤器会存在误判，但这并不影响他的发挥，很多场景下对误判有一定的容忍度，比如 URL 爬虫判重的问题。

假设 URL 长度平均为 64 字节，单纯存储 10 亿条，大约需要 60GB 的内存空间，若选择散列表，需要维持较小的装载因子，才能保证不会出现过多的散列冲突，会导致操作的性能下降。而且使用链表法解决冲突的话，还需要存储链表指针，所以构建散列表存储，可能需要的空间会超过 100GB。而且链表中的结点在内存中不是连续存储的，所以不能一下子加载到 CPU 缓存中，没法很好地利用到 CPU 高速缓存；判重还需要与链表中的每个 URL 做字符串匹配，性能会更加低。

而使用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有 10 亿，那可以用一个 10 倍大小的位图来存储，也就是 100 亿个二进制位，换算成字节，那就是大约 1.2GB。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。

### 执行效率

布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的。而在散列表的处理方式中，需要读取散列冲突拉链的多个数据，分别跟待判重的数据，进行字符串匹配。这个操作涉及很多内存数据的读取，是内存密集型的。CPU 计算可能是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式更加快速。

### 删除元素

想要删除元素，不能直接把该数所在的位置直接从 1 置为 0，因为这个位置可能存在其他元素。所以若想要把布隆过滤器中的元素删除，最简单的方法就是增加一个计数器，用于说明数组对应位置是否已经存在过数据，存在过一次就记为 1，两次则再自增一次，删除元素只需要把对应位置分别减 1 即可。

但是因为原本只要存一个二进制位，现在需要需要计数，所以需要占用更大的空间。

## 总结

布隆过滤器非常适合不需要 100% 准确，允许存在小概率误判的大规模判重场景，比如爬虫网页去重、统计大型网站的每天的 UV 数（每日访问用户数）。

布隆过滤器的**误判率主要与哈希函数的个数、位图的大小有关**，当不同的往布隆过滤器中放入数据后，位图中不是 true 的位置越来越少了，误判率就越来越高，所以对于无法事先知道要判重的数据个数的情况，需要支持自动扩容的功能。

当布隆过滤器中，**数据个数与位图大小的比例超过某个阈值时，就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。但是，若要判断某个数据是否在布隆过滤器中已经存在，就需要查看多个位图，相应的执行效率就降低了一些**。

若要支持删除元素操作，只需增加一个计数器，但会导致更大的内存占用。

位图、布隆过滤器应用广泛，Java 中的 BitSet 类就是一个位图，Redis 也提供了 BitMap 位图类，Google 的 Guava 工具包提供了 BloomFilter 布隆过滤器的实现。

## 参考资料

《数据结构与算法之美》