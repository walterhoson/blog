---
title: 基础数据结构-数组
description: 数组（Array）属于线性表数据结构，用一组连续的内存空间来存储一组具有相同类型的数据。支持随机访问，根据下标访问时间复杂度为 O(1)，不适合插入与删除
toc: true
authors: 
    - WayneShen
tags: 
    - Data Structure
    - Notes
categories: 
    - Data Structure
series: [Data Structure]
date: '2021-06-01T22:11:+08:00'
lastmod: '2021-06-01T22:11:29+08:00'
featuredImage: ''
draft: false
---

</br>
数组（Array）属于线性表数据结构，用一组连续的内存空间来存储一组具有相同类型的数据。支持随机访问，根据下标访问时间复杂度为 O(1)，不适合插入与删除。

<!--more-->

## 数组

### 实现随机访问

+ 线性表（Linear List）。数据排成类似一条线的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。非线性表是数据之间并不是简单的前后关系，比如二叉树、堆、图等。

+ 连续的内存空间和相同类型的数据。优点是**随机访问**，缺点是插入和删除数据变得低效，因为为了保证连续性，需要做大量数据搬迁工作。

所谓数组适合查找操作，但查找时间复杂度并非 O(1)，即便是排好序的数组，用二分查找，时间复杂度也是 O(logn)。

正确的表述应该是，**数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**。

### 实现思路

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。

需要随机访问时，通过以下寻址公式计算出该元素的内存地址，

```c
// data_type_size 表示数组中每个元素的大小
a[i]_address = base_address + i * data_type_size
```

### 低效的插入和删除

#### 插入操作

需要把插入位置往后的元素顺序的往后多一位。

若插入位置在末尾，则不需要再移动数据，时间复杂度为 O(1)。若在开头位置，则所有数据都要挪一位，所以最坏复杂度为 O(n)。

插入位置的概率一致，所以平均复杂度为 `(1+2+..+n) / n = O(n) `。若数组无序，则都可以插入到最后一位，复杂度就为 O(1)。

#### 删除操作

删除也需要搬移数据，不然中间会出现内存空洞，内存就不连续了。

和插入类似，若删除数组末尾的数据，则最好情况时间复杂度为 O(1)；若删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

### 警惕访问越界

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。

因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统。

### 下标从 0 开始

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。

如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 `type_size` 的位置，所以计算 a[k] 的内存地址只需要用这个公式：``a[k]_address = base_address + k * type_size``；

若从 1 开始计数，那个公式就变成了 ``a[k]_address = base_address + (k-1) * type_size`` ，每次随机访问数组元素都多了一次减法运算，对 CPU 来说，多了一次减法指令。

而数组属于非常基础的数据结构，通过下标随机访问也是基础操作，所以效率要做到极致。

## 参考资料

《数据结构与算法之美》
