---
title: 基础数据结构-链表
description: 链表并不需要一块连续的内存空间，而是通过“指针”将一组零散的内存块串联起来使用，内存块称为节点。
toc: true
authors: 
    - WayneShen
tags: 
    - Data Structure
    - Notes
categories: 
    - Data Structure
series: []
date: '2021-06-01T23:11:+08:00'
lastmod: '2021-06-01T23:11:29+08:00'
featuredImage: ''
draft: false
---

</br>

链表并不需要一块连续的内存空间，而是通过“指针”将一组零散的内存块串联起来使用，内存块称为**节点**。

<!--more-->

## 链表

### 单链表：

为了将所有的节点串起来，每个链表的节点除了存储数据之外，还记录链上的下一个节点的地址。这个记录下个节点地址的指针叫作 **后继指针 next**。

第一个节点叫作头节点，把最后一个节点叫作尾节点。其中，头节点用来记录链表的基地址。找到头节点就可以遍历得到整条链表。而尾节点特殊的地方是：**指针指向一个空地址 NULL，表示这是链表上最后一个节点**。

链表中插入或删除一个数据，并不需要为了保持内存的连续性而搬移节点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。

但，链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个节点一个节点地依次遍历，直到找到相应的节点。所以**查找需要 O(n) 的时间复杂度**。

### 循环链表

循环链表是一种特殊的单链表。与单链表唯一的区别就在尾节点。循环链表的**尾节点指针是指向链表的头节点**。像环一样首尾相连，所以叫作“循环”链表。

和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。

### 双向链表

支持两个方向，每个节点不止有**一个后继指针 next 指向后面的节点**，还有**一个前驱指针 prev 指向前面的节点**。

双向链表需要额外的两个空间来存储后继节点和前驱节点的地址。所以，存储同样多的数据，双向链表要比单链表占用更多的内存空间。

但可以支持双向遍历，这样也带来了双向链表操作的灵活性。双向链表可以支持 O(1) 时间复杂度的情况下找到前驱节点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

#### 删除操作：

**删除节点中“值等于某个给定值”的节点**
  
不管是单链表还是双向链表，为了查找到值等于给定值的节点，都需要从头节点开始一个一个依次遍历对比，直到找到值等于给定值的节点，然后再通过指针操作将其删除。

单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的节点对应的链表操作的总时间复杂度为 O(n)。

**删除给定指针指向的节点**

已经找到了要删除的节点，但删除某个节点 q 需要知道其前驱节点，而单链表并不支持直接获取前驱节点，所以，为了找到前驱节点，还是要从头节点开始遍历链表，直到 `p->next=q`，说明 p 是 q 的前驱节点。

但对于双向链表，这种情况比较有优势。因为双向链表中的节点已经保存了前驱节点的指针，不用像单链表那样遍历。

所以，单链表需要 O(n) ，而双向链表只需要 O(1) 。

同理插入操作，在链表的某个指定节点前面插入一个节点，双向链表也比单链表有很大的优势。双向链表时间复杂度 O(1) ，而单向链表需要 O(n) 的时间复杂度。


除了插入和删除，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。

因为，可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

### 双向循环链表

循环链表结合双向链表，就得到了双向循环链表。

### 对比数组

| 时间复杂度 | 数组 | 链表 |
| ---------- | ---- | ---- |
| 插入/删除  | O(n) | O(1) |
| 随机访问   | O(1) | O(n) |

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。

而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。

链表本身没有大小的限制，天然地支持动态扩容，这也是它与数组最大的区别。

### 设计思想

当内存空间充足时，如果更加追求代码的执行速度，就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构，即**用空间换时间**， 比如缓存。

相反，如果内存比较紧缺，比如代码跑在手机或单片机上，就要反过来**用时间换空间**的设计思路。

## 链表实现 LRU 缓存淘汰算法

常用缓存淘汰策略：

先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。

### 思路：

维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，就从链表头开始顺序遍历链表。

### 实现逻辑：

1. 如果此数据之前已经被缓存在链表中了，就遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   
   + 如果此时缓存未满，则将此节点直接插入到链表的头部；
  
   + 如果此时缓存已满，则链表尾节点删除，将新的数据节点插入链表的头部。

### 访问的时间复杂度分析

因为不管缓存有没有满，都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)

## 链表实现

### 理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到该变量。

### 警惕指针丢失和内存泄漏

插入节点时，一定要注意操作的顺序。比如插入节点，如果先断开，再接上就可能出现链表连接不上的情况。

```c
// 错误
p->next = new_node;
new_node->next = p->next;
// 正确
new_node->next = p->next;
p->next = new_node;
```

删除链表节点时，也一定要记得手动释放内存空间。否则，也会出现内存泄漏的问题。

### 利用哨兵简化实现难度

针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。

```c
// 头节点插入
if (head == null) {
	head = new_node;
}
// 单链表节点删除
p->next = p->next->next;
// 删除链表中的尾节点
if (head->next == null) {
	head = null;
}
```

引入哨兵节点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵节点。

也把这种有哨兵节点的链表叫**带头链表**。相反，没有哨兵节点的链表就叫作**不带头链表**。

哨兵节点是不存储数据的。因为哨兵节点一直存在，所以插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点，都可以统一为相同的代码实现逻辑了。

### 重点留意边界条件处理

用来检查链表代码是否正确的边界条件有这样几个：

+ 若链表为空时，代码是否能正常工作？
+ 若链表只包含一个节点时，代码是否能正常工作？
+ 若链表只包含两个节点时，代码是否能正常工作？
+ 代码逻辑在处理头节点和尾节点的时候，是否能正常工作？

### 举例画图，辅助思考

举例法和画图法

### 多写多练

常用操作：

+ 单链表反转
+ 链表中环的检测
+ 两个有序的链表合并
+ 删除链表倒数第 n 个节点
+ 求链表的中间节点

## 参考资料

《数据结构与算法之美》