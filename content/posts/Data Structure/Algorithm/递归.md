---
title: 递归算法
description: 递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。
toc: true
authors: 
    - WayneShen
tags: 
    - Data Structure
    - Notes
categories: 
    - Data Structure
series: []
date: '2021-06-02T10:15:+08:00'
lastmod: '2021-06-02T10:10:08+08:00'
featuredImage: ''
draft: false
---

</br>

递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。

<!--more-->

## 递归

所有的递归问题都可以用递推公式来表示。

### 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解，子问题就是数据规模更小的问题。

2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。

3. 存在递归终止条件。

### 编写递归代码

关键是**写出递推公式，找到终止条件**，然后将递推公式转化为代码。

也就是说，写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

而不用去想一层层的调用关系，不要视图用人脑去分解递归的每个步骤。

### 递归代码警惕堆栈溢出

函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。

系统栈或虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

解决方法：限制递归调用的最大深度。超过最大深度，不再递归，直接返回报错。但最大深度跟当前线程剩余的栈空间大小有关，无法事先计算。实时计算影响代码可读性。所以在最大深度比较小是可以使用这种方法。

### 递归代码要警惕重复计算

可以通过一个数据结构（比如散列表）来保存已经求解过的值。

### 将递归代码改写为非递归代码

递归代码表达力强，较简洁，但空间复杂度高，有堆栈溢出的风险，存在重复计算，过多的函数调用会增加耗时等。

可以手动模拟入栈，出栈的过程，改成非递归代码。

## 参考资料

《数据结构与算法之美》
