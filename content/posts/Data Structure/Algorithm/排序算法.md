---
title: 排序算法
description: 排序是常用的基础算法，不同的排序算法有着不同的时间与空间复杂度。
toc: true
authors: 
    - WayneShen
tags: 
    - Algorithm
    - Notes
categories: 
    - Algorithm
series: [Algorithm]
date: '2021-06-02T23:20:+08:00'
lastmod: '2021-06-02T23:20:08+08:00'
featuredImage: ''
draft: false
---

</br>

排序是常用的基础算法，不同的排序算法有着不同的时间与空间复杂度。

<!--more-->

## 排序算法分析

### 有序度和逆序度

有序度是数组中具有有序关系的元素对的个数，逆序度的定义正好相反（默认从小到大为有序）。

``有序元素对：a[i] <= a[j] && i < j ``。倒序数组的有序度是 0，完全有序数组的有序度是``n*(n-1)/2``，完全有序的数组的有序度也叫做**满有序度**。

``逆序元素对：a[i] > a[j] && i < j``。公式为：**逆序度 = 满有序度 - 有序度**。

排序的过程就是增加有序度，减少逆序度，最后达到满有序度。

### 执行效率

1. 最好情况、最坏情况、平均情况时间复杂度
   
2. 时间复杂度的系数、常数 、低阶

3. 比较次数和交换（或移动）次数

### 内存消耗

内存消耗可以通过空间复杂度来衡量。

原地排序（Sorted in place），就是特指空间复杂度是 O(1) 的排序算法。

### 稳定性

若待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序是否不变。

若前后顺序不变则是稳定的排序算法，前后顺序变了则是不稳定排序算法。

由于排序的不一定是数，还可能是对象，可能包含多个属性。

### 线性排序

线性排序（Linear sort）时间复杂度可以达到 O(n)。线性排序有，桶排序、计数排序和计数排序。

## 排序算法分类

### 冒泡排序

冒泡排序（Bubble Sort）只会操作相邻的两个数据。

每次冒泡操作都会比较相邻的两个元素，看是否满足大小关系要求。不满足就让它俩互换。

一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序。

#### 实现代码

```java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
    if (n <= 1) return;
    for (int i = 0; i < n; ++i) {
        // 提前退出冒泡循环的标志位
        boolean flag = false;
        for (int j = 0; j < n - i - 1; ++j) {
            if (a[j] > a[j+1]) { // 交换
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flag = true; // 表示有数据交换
            }
        }
        if (!flag) break; // 没有数据交换，提前退出
    }
}
```

#### 分析

1. 冒泡的过程只涉及相邻数据的交换操作，只要常量级的临时空间，所以**空间复杂度为 O(1)**，是**原地排序算法**。

2. 在排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等时，不做交换，相同大小的数据不会改变前后顺序，所以是**稳定的排序算法**。

3. 若数据已经有序，只需要进行一次冒泡，**最好情况时间复杂度是 O(n)**。若排序数据正好倒序，则需要进行 n 次冒泡，**最坏时间复杂度是 O(n<sup>2</sup>)**。适合小规模数据的排序。

**平均期望时间复杂度分析**

冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加 1。

不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是 ``n*(n-1)/2`` 初始有序度，也就是（满有序度-有序度）次交换操作。

最坏情况有序度为 0，进行 ``n*(n-1)/2`` 次交换；满有序度的最好情况，进行 0 次交换，取中间就是 ``n*(n-1)/4`` 次交换，而比较操作肯定要比交换操作多，而复杂度的上限是 O(n)，所以**平均情况下的时间复杂度就是 O(n)**。

### 插入排序

插入排序（Insertion Sort）首先，将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。

插入算法的核心思想是**取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空**，算法结束。

插入排序包含**元素的比较**和**元素的移动**。当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

#### 实现代码

```java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
    if (n <= 1) return;
    for (int i = 1; i < n; ++i) {
        int value = a[i];
        int j = i - 1;
        // 查找插入的位置
        for (; j >= 0; --j) {
            if (a[j] > value) {
                a[j+1] = a[j]; // 数据移动
            } else {
                break;
            }
        }
        a[j+1] = value; // 插入数据
    }
}
```

#### 分析

1. 插入排序并不需要额外的存储空间，所以**空间复杂度是 O(1)**，**是原地排序算法**。

2. 对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以**插入排序是稳定的排序算法**。

3. 若已经有序，不需要搬移任何数据，每次只需要比较一个数据就可以确定插入位置，所以**最好时间复杂度为 O(n)**。若数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动后续所有的数据，所以**最坏时间复杂度为 O(n<sup>2</sup>)**。数组插入一个数的平均时间复杂度为 O(n)，所以对于插入排序，每次插入操作相当于在数组中插入一个元素，循环 n 次插入操作，所以**平均时间复杂度为 O(n<sup>2</sup>)**。适合小规模数据的排序。

4. 插入排序的数据移动比冒泡排序要简单，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。数据量较大的时候插入排序就比冒泡要快。

### 选择排序

选择排序（Selection Sort）思路类似插入排序，也分**已排序区间**和**未排序区间**。但选择排序**每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾**。

#### 代码实现

```java
public int[] SelectionSort(int[] array) {
    for (int i = 0; i < array.length; i++) {
        int minIndex = i;
        for (int j = i + 1; j < array.length; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j;
            }
        }
        // 找到最小，就将其替换到最前面
        int tmp = array[i];
        array[i] = array[minIndex];
        array[minIndex] = tmp;
    }
    return array;
}
```

#### 分析

1. 选择排序**空间复杂度为 O(1)**，是**原地排序算法**。

2. 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性，所以选择排序是**不稳定的排序算法**。

3. **最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n<sup>2</sup>)**。适合小规模数据的排序。

### 归并排序

把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，使整个数组就都有序了。

使用分治的思想。将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。使用递归来实现。

**分治是一种解决问题的处理思想，递归是一种编程技巧**。

#### 递推公式

``merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))``

#### 终止条件

当 ``p >= r``，则不用再继续分解。

#### 代码实现

```c
// 归并排序算法，A 是数组，n 表示数组大小
merge_sort(A, n) {
    merge_sort_c(A, 0, n-1)
}
// 递归调用函数
merge_sort_c(A, p, r) {
    // 递归终止条件
    if p >= r then return
    // 取 p 到 r 之间的中间位置 q
    q = (p+r) / 2
    // 分治递归
    merge_sort_c(A, p, q)
    merge_sort_c(A, q+1, r)
    // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
    merge(A[p...r], A[p...q], A[q+1...r])
}

// 合并，申请临时数组 tmp，两个指针比较两个数组，依次放入 tmp 中，并指针后移，最后 tmp 拷贝到原数组中
merge(A[p...r], A[p...q], A[q+1...r]) {
    var i := p，j := q+1，k := 0 // 初始化变量 i, j, k
        var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组
            while i<=q AND j<=r do {
                if A[i] <= A[j] {
                    tmp[k++] = A[i++] // i++ 等于 i:=i+1
                } else {
                    tmp[k++] = A[j++]
                }
            }
    // 判断哪个子数组中有剩余的数据
    var start := i，end := q
        if j<=r then start := j, end:=r
            // 将剩余的数据拷贝到临时数组 tmp
            while start <= end do {
                tmp[k++] = A[start++]
            }
    // 将 tmp 中的数组拷贝回 A[p...r]
    for i:=0 to r-p do {
        A[p+i] = tmp[i]
    }
}
```

#### 分析

**稳定性**

在合并的过程中，遇到相同的值，先将前面的数据放入 tmp，可以保证前后顺序不变，所以**是稳定的**。

**时间复杂度**

由于问题被分解了，所以，``T(a) = T(b) + T(c) + K``，不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。

假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以公式可以写成：

```
// n=1 时，只需要常量级的执行时间，所以表示为 C。
T(1) = C;
// n>1
T(n) = 2*T(n/2) + n;
// 推导
T(n) = 2*T(n/2) + n
    = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2 * n
    = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3 * n
    = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
    ......
    = 2^k * T(n/2^k) + k * n
```

当 T(n/2<sup>k</sup>) = T(1) 时，也就是 n/2<sup>k</sup>  = 1，得到 k = log<sub>2</sub>n，将 k 带入上面的公式，得到 T(n)=Cn+nlog<sub>2</sub>n，

所以归并排序的**时间复杂度为 O(nlogn)**。执行效率与原始数组的有序度无关，**非常稳定**，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。

**空间复杂度**

**非原地排序**，需要额外的存储空间来合并。

递归代码的空间复杂度不能像时间复杂度一样累加，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。

在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以**空间复杂度是 O(n)**。

### 快速排序

快排（Quicksort）也是利用分治的思想，若要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点。一般情况下，可以选择 P 到 r 区间的最后一个元素）。

遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。

经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1, 就说明所有的数据都有序了。

#### 递推公式

``quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)``

#### 终止条件

``p >= r``

#### 代码实现

```c
// 快速排序，A 是数组，n 表示数组的大小
quick_sort(A, n) {
    quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r 为下标
quick_sort_c(A, p, r) {
    if p >= r then return
        q = partition(A, p, r) // 获取分区点
        quick_sort_c(A, p, q-1)
        quick_sort_c(A, q+1, r)
}

partition(A, p, r) {
    pivot := A[r]
        i := p
            for j := p to r-1 do {
                if A[j] < pivot {
                    swap A[i] with A[j]
                        i := i+1
                }
            }
    swap A[i] with A[r]
        return i
}
```

partition() 分区函数，随机选择一个元素作为 pivot（一般选择 p 到 r 区间内的最后一个元素），然后对 A[p...r] 分区，函数返回 pivot 的下标。

通过交换实现分区内原地排序。分区内处理会导致相同的值，前后顺序调颠倒，所以并**不是稳定的排序算法**。

#### 分析

**时间复杂度**

快排通过递归实现，每次分区操作都正好把数组分成大小接近相等的两个小区间，推导方式与归并相同。

时间复杂度为 O(nlogn)。但前提是 pivot 选择都很合适，正好能将大区间对等地一分为二。

举个例子，原数组 1，3，5，6，8，若每次选择最后一个元素作为 pivot，那个每次分区得到的两个区间都不均等，需要进行大约 n 次分区操作，每次分区平均药扫描大约 n/2 个元素，此时复杂度从 O(nlogn) 退化到了 O(n<sup>2</sup>)。

所以分区及其均衡时是**最好情况时间复杂度为 O(nlogn)**，分区及其不均衡时是**最坏情况时间复杂度 O(n<sup>2</sup>)**。

**平均的时间复杂度为 O(nlogn)**。只有极少数情况会退化到 O(n<sup>2</sup>)。

**与归并排序区别**

都使用了分治的思想，代码都通过递归来实现，过程非常相似。主要需要理解归并的递归公司和 merge() 合并函数，快排的递推公式和 partition() 分区函数。

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。

归并排序是一种在任何情况下时间复杂度（O(nlogn)）都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。

归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

快速排序算法虽然最坏情况下的时间复杂度是 O(n)，但平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n<sup>2</sup>) 的概率非常小，可以通过合理地选择 pivot 来避免这种情况。

### 桶排序

桶排序（Bucket sort）原理是，将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

假如要排序的数据有 n 个，均匀的划分到 m 个桶内，每个桶内有 ``k = n/m`` 个元素，每个桶内使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度是 O(m * k * logk)，因为 ``k=n/m``，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。

**当桶的个数 m 接近数据个数 n 时**，log(n/m) 就是一个非常小的常量，这个时候桶排序的**时间复杂度接近 O(n)**。

#### 分析

**桶排序对数据要求严格**

+ 待排序数据需要很容易被划分到 m 个桶中。

+ 数据在每个桶之间要分布比较均匀。极端情况所有数据被划到一个桶里，就会退化成 O(nlogn) 了。

**桶排序比较适合用在外部排序**

所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

如果数据量较大，先扫描一遍，了解数据范围。然后划分桶（文件），然后将文件中的数据依次读入内存中使用快排进行排序。

### 计数排序

计数排序（Counting sort）其实是桶排序的一种特殊情况。

#### 原理

当要排序的 n 个数据，所处的范围并不大时，比如最大值是 k，就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

比如全省高考分数排序。假设有 8 个考试，分数在 0-5。分别是 2、5、3、0、2、3、0、3，放在数组 A 中。遍历一遍后，放入 C[6] 数组中，下标对应分数的值，值对应该分数的个数。

3 分的有 3 个，小于 3 分的有 4 个，所以 3 在原数组中应该排在下标 4，5，6 的位置。

对 C[6] 数组顺序求和（**C[k] 里存储小于等于分数 k 的考生个数**）。

从后到前依次扫描数组 A。比如，当扫描到 3 时，可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。

当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。

以此类推，当扫描到第 2 个分数为 3 的考生时，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。

![img](../../../assets/排序算法/image-20201110192607367.png)

#### 代码实现

```java
// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
    if (n <= 1) return;
    // 查找数组中数据的范围
    int max = a[0];
    for (int i = 1; i < n; ++i) {
        if (max < a[i]) {
            max = a[i];
        }
    }
    int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]
    for (int i = 0; i <= max; ++i) {
        c[i] = 0;
    }
    // 计算每个元素的个数，放入 c 中
    for (int i = 0; i < n; ++i) {
        c[a[i]]++;
    }
    // 依次累加
    for (int i = 1; i <= max; ++i) {
        c[i] = c[i-1] + c[i];
    }
    // 临时数组 r，存储排序之后的结果
    int[] r = new int[n];
    // 计算排序的关键步骤，有点难理解
    for (int i = n - 1; i >= 0; --i) {
        int index = c[a[i]]-1;
        r[index] = a[i];
        c[a[i]]--;
    }
    // 将结果拷贝给 a 数组
    for (int i = 0; i < n; ++i) {
        a[i] = r[i];
    }
}
```

#### 适用场景

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。

而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。比如 [-100.100]，先全部加 100。

### 基数排序

基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。除了整数还是可以是字符串（比如名字或日期）和特定格式的浮点数。

#### 示例

![img](../../../assets/排序算法/image-20201110193858927.png)

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。

如果数据有 k 位，就需要 k 次桶排序/计数排序。总时间复杂度为 O(k*n），当 k 不大时，比如手机号码，k 最大就是 11，所以时间复杂度近似为 O(n)。如果每一位的数据范围不能太大，就不可以用线性排序算法来排序了，就无法做到 O(n) 了。

若长度不一致，可以进行后面补 0 的补位操作。根据 ASCII 值，所有字母都大于 0。

<!-- ### 希尔排序 -->

## 排序优化

主要痛点就是需要一个通用的、高性能的排序函数。高性能是首要目的，但同时也需要根据场景选择更合适的算法。

### 选择合适的排序算法

![img](../../../assets/排序算法/image-20201110194439480.png)

若是对小规模数据进行排序，可以选择时间复杂度是 O(n ) 的算法；若对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。

所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。

比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。归并排序尽管平均情况、最坏情况下的时间复杂度都是 O(nlogn)，但由于不是原地排序，空间复杂度为 O(n)，所以也并不是很受欢迎。

小规模数据面前，O(n) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。可能原复杂度在没有省略低阶、系数、常数之前是 O(knlogn + c)， k 和 c 有可能还是一个比较大的数。

比如 k = 1000，c=200，小规模数据数量 n=100，此时 n<sup>2</sup> 就小于 knlogn+c 。

### 优化快速排序

快排由于 pivot 点选择问题可能导致退化成 O(n<sup>2</sup>)。所以需要选择一个理想的分区点，**被分区点分开的两个分区中，数据的数量差不多**。

可以通过：

+ **三数取中法**。从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样肯定比单纯取某个数据要好，但如果数据量较大，该方法就不够了，可能需要”五数取中“ 或 ”十数取中“。

+ **随机法**。每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。

## 参考资料

《数据结构与算法之美》