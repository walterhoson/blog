---
title: MySQL选错索引分析
date: 2020-09-21 23:43:11
tags: [MySQL,note]
description: 分析在使用MySQL过程中，选错索引的几种原因，并总结如何正确使用索引...
read_more: 阅读全文
categories: MySQL
toc: true
---


## MySQL为什么有时候会选错索引?

优化器选择索引，目的是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里，扫描行数是影响执行代价的因素之一。**扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少**。

但扫描行数并不是唯一的判断标准，优化器还会结合**是否使用临时表**、**是否排序**等因素进行综合判断。

### 如何判断扫描行数

MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。

这个统计信息就是索引的“区分度”。一个索引上不同的值越多，这个索引的区分度就越好。一个索引上不同的值的个数，称之为“基数”(cardinality)。也就是说，这个基数越大，索引的区分度越好。

可以使用 ``show index from t``  查看一个索引的基数。



#### 如何获取索引的基数

由于一行行统计代价太高，MySQL通过采样统计来获得索引的基数。所以并不准确。

InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。由于数据表会持续更新，所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。``analyze table t`` 可以用来重新统计索引信息。

在 MySQL 中，通过设置参数 ``innodb_stats_persistent`` 的值来选择两种存储索引统计的方式

+ 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。 
+ 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。

除了索引统计，对于具体语句，**优化器还要判断执行这个语句本身要扫描多少行**。explain 里 rows 字段表示预计扫描行数。但其实如果使用索引后，每次从索引上拿到值，都要回主键索引上查出整行数据（回表消耗），这个代价优化器也要算进去的。所以会导致优化器会误认为预计扫描行数多的但扫描的是主键索引的更快，导致选中了非执行时间最优的方式。



### 索引选择异常和处理

1. 使用 **force index** 强行选择一个索引，为了及时变更，属于没有办法的办法

   MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就**直接选择这个索引**，不再评估其他索引的执行代价。

2. **考虑修改语句，引导MySQL使用期望的索引**

   比如：它认为使用某个索引**可以避免排序** (当前的索引本身已经是有序的了，如果选择他的话，不需要再做排序，只需要遍历)，所以即使扫描行数多，也判定为代价更小。

   此时重写SQL，让优化器认为不管选哪个索引都需要排序。比如 “order by b limit 1” 改成 “order by b,a limit 1”。因此，扫描行数成了影响决策的主要条件，此时优化器就只会选择扫描行数较少的。**但必须要保证修改前后语义一致**。

3. 在有些场景下，可以**新建一个更合适的索引**，来提供给优化器做选择，或删掉误用的索引。

   

### 总结：

选错原因：

1. 优化器判断使用主键索引不需要回表操作，所以误认为扫描行数多的但是为主键索引的更快
2. 优化器判断使用某个索引可以避免排序