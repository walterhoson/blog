---
title: MySQL中count原理浅析
date: 2020-09-28 20:59:40
tags: [MySQL,笔记]
description: 
read_more: 阅读全文
categories: MySQL
toc: true
---

## count(*)的实现方式

+ MyISAM 引擎把一个表的总行数存在了磁盘上，执行 count(*) 时会直接返回这个数，效率很高（有 where条件也需要过滤）
+ InnoDB 引擎执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累积计数。

为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？

<!--more-->

因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。

MySQL也做了优化。普通索引树叶子节点只存主键值，比主键索引树小，对于 count(*) 遍历哪个索引树得到的结果逻辑上都一样。因此，MySQL 优化器会找到最小的那棵树来遍历。 **在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一**。

通过 ``show table status`` 结果中，也有Rows也用于表示表当前有多少行，但其实这个数据也是通过采样估算来的，所以也很不准，官方文档表示误差可能打到40%-50%，所以不可用。

## 业务实现

如果有页面频繁要显示系统的操作记录总数，只能通过业务实现。

### 用缓存系统保存计数

缺点：

+ redis等缓存不可靠，容易丢失更新，导致数据不一致
+ 即使 Redis 正常工作，这个值还是逻辑上不精确的。因为再并发系统里，无法精确控制不同线程的执行时刻。
+ 不支持分布式事务，无法拿到精确一致的视图

### 用数据库保存计数

把这个计数直接放到数据库里单独的一张计数表中。利用事务的原子性和隔离性，保持数据逻辑上的一致。

当然需要新更新业务数据，再更新计数表。因为计数表，更加容易产生行锁竞争，所以放在后面更新最大程度的减少事务间的锁等待，提升并发度。

## 不同count用法

count()是聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。

count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；

count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。

+ count(主键id)

  InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

+ count(1)

  InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
  count(1) 执行得要比 count(主键 id) 快。因为**从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作**。

+ count(字段)

  + 如果“字段”是定义为 not null，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
  + 如果“字段”定义允许为 null，执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

+ count(*)

  并不会把全部字段取出来，而是专门做了优化。count(*) 肯定不是 null，按行累加。即：不取值，直接累加

> 按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(\*)
> 尽量使用 count(*)。
