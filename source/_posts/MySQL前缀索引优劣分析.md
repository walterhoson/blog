---
title: MySQL前缀索引优劣分析
date: 2020-09-23 22:53:20
tags: [MySQL,笔记]
description: 
read_more: 阅读全文
categories: MySQL
toc: true
---


MySQL 支持前缀索引的，可以定义字符串的一部分作为索引。默认地， 如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

```sql
-- index1包含整个字符串
alter table User add index index1(email);
-- index2 只取前6个字节
alter table User add index index2(email(6));
```

<!-- more -->


![index1-完整索引](image-20200923225333337.png)

![index2-前缀索引](image-20200923225516970.png)

前缀索引**优势是占用空间更小**，但**可能会增加额外的记录扫描次数**。

执行顺序：

1. 索引树上找到 zhangs，找到第一个 ID1
2. 到主键树上找到主键值为 ID1的行，判断 email 值是否为 zhangsan@xxx.com，不是则丢弃
3. 取到index2上ID1下一个，发现仍为zhangs，取出ID2，再到主键树取整行，发现是，则记入结果集。
4. 重复上述步骤，直到 index2 上取到值部位 zhangs 时，循环结束。

注意：使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。所以建索引时，关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。当然，使用前缀索引很可能会损失区分度，所以需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，就可以选择前缀长度为 6。

```sql
--取不同长度的前缀来看这个值，看适合多少字节的前缀索引
select
  count(distinct left(email,4))as L4,
  count(distinct left(email,5))as L5,
  count(distinct left(email,6))as L6,
  count(distinct left(email,7))as L7,
from User;  
```

## 前缀索引对覆盖索引的影响

比如上面的 index1 利用覆盖索引，找到结果直接返回了，不需要会主键索引再查一次。而使用index2 是前缀索引，则需要，前缀索引再长也没用，因为系统不知道前缀索引是否截断了完整信息。即**使用前缀索引就用不上覆盖索引对查询性能的优化了**

索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。

### 其他方式

+ **使用倒序存储**。如果数据倒过来再使用前缀索引的话，有比较好的区分度的话（使用distinct验证）
+ **使用hash字段**。表上再创建一个整数字段，来保存字段的校验码，同时在这个字段上创建索引。缩小索引长度，但只支持等值查询

### 两者比较

1. 从**占用的额外空间**来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。

2. 在 **CPU 消耗**方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。

3. 从**查询效率**上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值 虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。

## 给字符串字段加索引的方式总结

+ 直接创建完整索引，这样可能比较占用空间;
+ 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引;
+ 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题，不支持范围扫描;
+ 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，不支持范围扫描。 