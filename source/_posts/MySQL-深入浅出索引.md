---
title: 深入浅出MySQL索引
date: 2020-09-11 23:31:01
tags: [MySQL,笔记]
description: 
read_more: 阅读全文
categories: MySQL
toc: true
---

## 索引的常见模型

<!-- more -->

### 常见索引数据结构：

+ 哈希表
  + 不是有序的，哈希索引做区间查询的速度很慢。
  + 无法利用索引进行排序，也无法实现多列联合索引的最左匹配原则
  + 哈希表这种结构适用于只有等值查询的场景，比如 Memcached 以及其他一些 NoSQL 引擎
  + 还会存在 hash 碰撞的问题
+ 有序数组
  + 有序数组在**等值查询**和**范围查询**场景中的性能就都非常优秀
  + 仅仅看查询效率，有序数组就是最好的数据结构。
  + 更新数据时，若中间插入一条记录，就必须挪动后面所有记录，成本太高。
  + 有序数组索引只适用于**静态存储**引擎
+ 搜索树
  + 二叉搜索树
    + 左子节点 < Node < 右子节点 
  + 平衡二叉树的查询/更新复杂度 O(logN) 
  + 多叉树
    + 多叉树就是每个节点有多个子节点，子节点之间的大小保证从左到右递增
  + 二叉树搜索效率最高，但是实际上大多数的数据库存储却并不使用二叉树。其原因
    是，索引不止存在内存中，还要写到磁盘上。
  + N叉树，降低树高，加快查找时间，以及适配磁盘的访问模式，被广泛应用在搜索引擎

### 索引选择

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么就不应该使用二叉树，而是要使用“N 叉”树。N 取决于数据块的大小。

以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，17 亿。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。



## InnoDB的索引模型

在 InnoDB 中，表是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。

1. 主键索引。叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为**聚簇索引**（clustered index）

2. 普通索引。叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为**辅助索引**，也叫二级索引（secondary index）


两者查询区别：

+ 查询条件是主键，通过主键查询方式，则只需要搜索 ID 这棵 B+树；
+ 查询条件是非主键但有索引，即普通索引查询方式，则需要先搜索条件的索引树，得到主键的值，再到主键索引树搜索一次。这个过程称为**回表**。

基于非主键索引的查询需要多扫描一棵索引树。因此，在应用中应尽量使用主键查询。



## 索引维护

1. B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。中间插入，需要逻辑上挪动后面的数据，空出位置。如果后一个数据页已经满了。根据 B+ 树算法，这时候需要**申请一个新的数据页，然后挪动部分数据过去，这个过程叫页分裂**。在这种情况下，性能自然会受影响。
2. 除了性能外，**页分裂操作还影响数据页的利用率**。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
3. 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低后，会将数据页做合并。合并的过程可以认为是分裂的逆过程。
4. **重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高**，也就是索引更紧凑、更省空间。
5. 自增主键的插入数据模式，符合递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。从性能和存储空间方面考量，自增主键往往是更合理的选择。
6. 由于每个非主键索引的叶子节点上都是主键的值，如果用业务数据做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，长整型（bigint）则是 8 个字节。
7. **主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小**。
8. 在**只有一个索引**，**索引必须是唯一索引**，情况下适合用业务字段做主键



## 覆盖索引

若执行的语句是 ``select ID from T where k between 3 and 5``，这时只需要查 ID 的值，而ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，**索引 k 已经“覆盖了”查询结果的需求，称为覆盖索引**。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

索引覆盖，创建联合索引，在用这个索引查询时，叶子节点存储了需要查询的所有字段，这样就可以避免回表操作了。



## 最左前缀原则

B+ 树这种索引结构，可以利用索引的**最左前缀**，来定位记录。不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。也叫最左匹配原则。

如 index(a,b,c) 联合索引，则相当于创建了 a 单列索引，(a,b) 联合索引，和 (a,b,c) 联合索引。

联合索引内部就是有序的，可以理解为类似于 order by a,b,c 这样的排序规则。会先根据 a 排序，若 a 相同，再根据 b 排序，依次类推。

**在建立联合索引的时候，如何安排索引内的字段顺序**

1. 索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，**第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的**。
2. 其次考虑的原则是**空间**。比如市民表的情况，name 字段是比 age 字段大的 ，那就建议创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。
3. 若条件为``where a = 1 and c = 1``，此时也是可以走到index(a,b,c) 联合索引。
4. 若 ``select a,b,c from t where c = 1``，此时也可以走到该索引，但不满足最左匹配原则，explain为index，即扫描整颗覆盖索引树。遇到范围查询(>、<、between、like)，也是如此，会停止匹配。



## 索引下推

MySQL5.6 引入的索引下推优化（index condition pushdown），可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

无下推。每个虚线箭头表示回表一次。

![无索引下推](image-20200911175237452.png)

``select * from t where name = '张三' and age = 10``

有下推。在内部判断了age是否等于10，不等于的直接跳过，只需要回表2次。

![符合索引下推](image-20200911175308566.png)